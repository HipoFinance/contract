#include "imports/utils.fc";

builder pack_loan_request
    ( int min_payment
    , int validator_reward_share
    , int loan_amount
    , int accrued_amount
    , int staked_tokens
    , cell new_stake_msg
    ) {
    return begin_cell()
        .store_coins(min_payment)
        .store_uint(validator_reward_share, 14)
        .store_coins(loan_amount)
        .store_coins(accrued_amount)
        .store_coins(staked_tokens)
        .store_ref(new_stake_msg);
}

(int, int, int, int, int, cell) unpack_loan_request(slice s) {
    int min_payment = s~load_coins();
    int validator_reward_share = s~load_uint(14);
    int loan_amount = s~load_coins();
    int accrued_amount = s~load_coins();
    int staked_tokens = s~load_coins();
    cell new_stake_msg = s~load_ref();
    return ( min_payment, validator_reward_share, loan_amount, accrued_amount, staked_tokens, new_stake_msg );
}

builder pack_participation_data
    ( int state
    , cell requests
    , cell accepted
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) {
    return begin_cell()
        .store_uint(state, 3)
        .store_dict(requests)
        .store_dict(accepted)
        .store_dict(staked)
        .store_dict(recovering)
        .store_coins(total_staked)
        .store_varint16(total_recovered)
        .store_uint(current_vset_hash, 256)
        .store_uint(stake_held_for, 32)
        .store_uint(stake_held_until, 32);
}

(int, cell, cell, cell, cell, int, int, int, int, int) unpack_participation_data(slice s) {
    int state = s~load_uint(3);
    cell requests = s~load_dict();
    cell accepted = s~load_dict();
    cell staked = s~load_dict();
    cell recovering = s~load_dict();
    int total_staked = s~load_coins();
    int total_recovered = s~load_varint16();
    int current_vset_hash = s~load_uint(256);
    int stake_held_for = s~load_uint(32);
    int stake_held_until = s~load_uint(32);
    return
        ( state
        , requests
        , accepted
        , staked
        , recovering
        , total_staked
        , total_recovered
        , current_vset_hash
        , stake_held_for
        , stake_held_until
        );
}

() stake_ton
    ( int msg_ton
    , int fwd_fee
    , slice src
    , int query_id
    , int stake_amount
    , slice recipient
    , slice return_excess
    , int forward_ton_amount
    , slice forward_payload
    ) impure {

    slice ds = get_data().begin_parse();
    int total_ton = ds~load_coins();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell participations = ds~load_dict();
    cell wallet_code = ds~load_ref();

    if (recipient.preload_uint(2) == 0) {
        recipient = src;
    }
    if (return_excess.preload_uint(2) == 0) {
        return_excess = src;
    }

    ( int src_wc, _ ) = parse_std_addr(src);
    ( int recipient_wc, _ ) = parse_std_addr(recipient);
    int fwd_count = forward_ton_amount ? 2 : 1;
    int min_ton =
            stake_amount +
            forward_ton_amount +
            ;; 3 messages: root->wallet, wallet->owner (for notification), wallet->return (optional)
            fwd_count * fwd_fee +
            fee::root_stake_gas_consumption +
            fee::wallet_gas_consumption +
            fee::wallet_storage;

    throw_unless(err::only_basechain_allowed, (src_wc == chain::base) & (recipient_wc == chain::base));
    throw_unless(err::insufficient_fee, msg_ton >= min_ton);

    int tokens = stake_amount;
    if (total_ton > 0) {
        tokens = muldiv(stake_amount, total_staked_tokens + total_unstaked_tokens, total_ton);
    }

    total_ton += stake_amount;
    total_staked_tokens += tokens;

    int storage_fee = 0; ;; todo: use new TVM to calculate storage fee
    msg_ton -= stake_amount + storage_fee + fee::root_stake_gas_consumption;

    ( builder wallet
    , cell state_init
    , _
    ) = create_wallet_address(recipient.to_builder(), my_address(), wallet_code);
    builder body = begin_cell()
        .store_uint(op::receive_tokens, 32)
        .store_uint(query_id, 64)
        .store_coins(tokens)
        .store_slice(src)
        .store_slice(return_excess)
        .store_coins(forward_ton_amount)
        .store_slice(forward_payload);
    send_msg(true, wallet, state_init, body, msg_ton, send::pay_gas_separately);

    begin_cell()
        .store_coins(total_ton)
        .store_coins(total_staked_tokens)
        .store_coins(total_unstaked_tokens)
        .store_dict(participations)
        .store_ref(wallet_code)
        .store_slice(ds)
        .end_cell()
        .set_data();
}

() advanced_stake(int msg_ton, int fwd_fee, slice src, slice s) impure {
    int query_id = s~load_uint(64);
    int stake_amount = s~load_coins();
    slice recipient = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    int forward_ton_amount = s~load_coins();
    slice forward_payload = s;
    s~skip_bits(1); ;; check if forward_payload is provided

    stake_ton
        ( msg_ton
        , fwd_fee
        , src
        , query_id
        , stake_amount
        , recipient
        , return_excess
        , forward_ton_amount
        , forward_payload
        );
}

() simple_stake(int msg_ton, int fwd_fee, slice src) impure {
    int simple_stake_fee =
            2 * fwd_fee +
            fee::root_stake_gas_consumption +
            fee::wallet_gas_consumption +
            fee::wallet_storage;
    int stake_amount = msg_ton - simple_stake_fee;

    throw_unless(err::insufficient_fee, stake_amount > 0);

    stake_ton
        ( msg_ton
        , fwd_fee
        , src
        , 0
        , stake_amount
        , "0"s.skip_bits(2) ;; no recipient: addr_none
        , "0"s.skip_bits(2) ;; no return_excess: addr_none
        , 0
        , "0"s.skip_bits(3) ;; empty payload
        );
}

() unstake_reserve(int msg_ton, slice src, slice s) impure {
    slice ds = get_data().begin_parse();
    int total_ton = ds~load_coins();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell participations = ds~load_dict();
    cell wallet_code = ds~load_ref();

    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    slice owner = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    s.end_parse();

    ( _, _, int wallet_addr ) = create_wallet_address(owner.to_builder(), my_address(), wallet_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::base) & (src_addr == wallet_addr));
    throw_unless(err::insufficient_funds, tokens <= total_staked_tokens);

    total_staked_tokens -= tokens;
    total_unstaked_tokens += tokens;

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, return_excess.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    begin_cell()
        .store_coins(total_ton)
        .store_coins(total_staked_tokens)
        .store_coins(total_unstaked_tokens)
        .store_dict(participations)
        .store_ref(wallet_code)
        .store_slice(ds)
        .end_cell()
        .set_data();
}

() withdraw_ton(int msg_ton, int fwd_fee, slice src, slice s) impure {
    slice ds = get_data().begin_parse();
    int total_ton = ds~load_coins();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell participations = ds~load_dict();
    cell wallet_code = ds~load_ref();

    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    int incentive = s~load_coins();
    slice owner = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    s.end_parse();

    ( builder wallet, _, int wallet_addr ) = create_wallet_address(owner.to_builder(), my_address(), wallet_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::base) & (src_addr == wallet_addr));
    throw_unless(err::insufficient_funds, tokens <= total_unstaked_tokens);

    int ton_balance = get_balance().pair_first();
    int ton_balance_before_msg = ton_balance - msg_ton;
    int available_ton = ton_balance_before_msg - fee::root_storage;

    if (tokens > available_ton) {
        builder body = begin_cell()
            .store_uint(op::withdraw_failed, 32)
            .store_uint(query_id, 64)
            .store_coins(tokens)
            .store_coins(incentive)
            .store_slice(return_excess);
        send_msg(true, wallet, null(), body, 0, send::remaining_value);

        return ();
    }

    total_ton -= tokens;
    total_unstaked_tokens -= tokens;

    builder body = begin_cell()
        .store_uint(op::withdrawal_notification, 32)
        .store_uint(query_id, 64);
    send_msg(false, owner.to_builder(), null(), body, tokens, send::pay_gas_separately);

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, return_excess.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    begin_cell()
        .store_coins(total_ton)
        .store_coins(total_staked_tokens)
        .store_coins(total_unstaked_tokens)
        .store_dict(participations)
        .store_ref(wallet_code)
        .store_slice(ds)
        .end_cell()
        .set_data();
}

() provide_wallet_address(int msg_ton, int fwd_fee, slice src, slice s) impure {
    slice ds = get_data().begin_parse();
    cell wallet_code = ds~load_ref();

    int query_id = s~load_uint(64);
    slice owner = s~load_msg_addr();
    int include_address? = s~load_uint(1);
    s.end_parse();

    ( int owner_wc, _ ) = parse_std_addr(owner);

    throw_unless(err::insufficient_fee, msg_ton > fwd_fee + fee::provide_address_gas_consumption);

    builder wallet = null();
    if (owner_wc == chain::base) {
        ( wallet, _, _ ) = create_wallet_address(owner.to_builder(), my_address(), wallet_code);
    } else {
        wallet = begin_cell().store_uint(0, 2); ;; addr_none
    }
    cell included_address = include_address?
        ? owner.to_builder().end_cell()
        : null();
    builder body = begin_cell()
        .store_uint(op::take_wallet_address, 32)
        .store_uint(query_id, 64)
        .store_builder(wallet)
        .store_maybe_ref(included_address);
    send_msg(true, src.to_builder(), null(), body, 0, send::remaining_value);
}

() throw_if_already_staked(cell participations, int last_round_since, int validator_addr) impure {
    do {
        ( int last_round_since, slice pd, int f? ) = participations.udict_get_prev?(32, last_round_since);
        if (f?) {
            pd~skip_bits(3);
            pd~skip_dict();
            pd~skip_dict();
            cell staked = pd~load_dict();
            ( _, int e? ) = staked.udict_get?(256, validator_addr);
            throw_if(err::already_staked, e?);
        }
    } until (~ f?);
}

;; todo: add a ceiling for number of saved requests
() save_loan_request(int msg_ton, slice src, slice s) impure {
    slice ds = get_data().begin_parse();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell wallet_code = ds~load_ref();
    cell rewards_dict = ds~load_dict();
    cell participations = ds~load_dict();

    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    slice validator = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    int round_since = s~load_uint(32);
    int loan_amount = s~load_coins();
    int min_payment = s~load_coins();
    int validator_reward_share = s~load_uint(14);
    cell new_stake_msg = s~load_ref();
    s.end_parse();
    check_new_stake_msg(new_stake_msg.begin_parse());

    ( _, int validator_addr ) = parse_std_addr(validator);
    ( _, int next_round_since ) = get_vset_times(config::current_validators);
    ( slice pd, int f? ) = participations.udict_get?(32, next_round_since);
    int state = participation::open;
    cell requests = new_dict();
    if (f?) {
        state = pd~load_uint(3);
        requests = pd~load_dict();
        ( slice old_request, int e? ) = requests.udict_get?(256, validator_addr);
        if (e?) {
            ( _, _, _, _, int staked_tokens, _ ) = unpack_loan_request(old_request);
            tokens += staked_tokens;
        }
    }

    int max_punishment = max_recommended_punishment_for_validator_misbehaviour(loan_amount);
    ( _, _, int wallet_addr ) = create_wallet_address(validator.to_builder(), my_address(), wallet_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);
    int min_ton =
            fee::save_loan_gas_consumption +
            fee::one_ton +
            fee::pool_storage +
            fee::new_stake_gas_consumption +
            3 * fee::recover_stake_gas_consumption;

    throw_unless(err::access_denied, (src_wc == chain::base) & (src_addr == wallet_addr));
    throw_if_already_staked(participations, next_round_since, validator_addr);
    throw_unless(err::not_accepting_loan_requests, state == participation::open);
    throw_unless(err::not_accepting_loan_requests, round_since == next_round_since);
    throw_unless(err::insufficient_fee, msg_ton >= min_ton);
    throw_unless(err::insufficient_funds, tokens >= min_payment + max_punishment);

    builder request = pack_loan_request(min_payment, validator_reward_share, loan_amount, 0, tokens, new_stake_msg);
    requests~udict_set_builder(256, validator_addr, request);
    builder pdb = pack_participation_data(state, requests, new_dict(), new_dict(), new_dict(), 0, 0, 0, 0, 0);
    participations~udict_set_builder(32, next_round_since, pdb);
    if (return_excess.preload_uint(2) != 0) {
        builder excess = begin_cell()
            .store_uint(op::gas_excess, 32)
            .store_uint(query_id, 64);
        send_msg(false, return_excess.to_builder(), null(), excess, msg_ton - min_ton, send::ignore_errors);
    }

    begin_cell()
        .store_coins(total_staked_tokens)
        .store_coins(total_unstaked_tokens)
        .store_ref(wallet_code)
        .store_dict(rewards_dict)
        .store_dict(participations)
        .store_slice(ds)
        .end_cell()
        .set_data();
}

cell sort_loan_requests(cell requests) {
    cell sorted = new_dict();
    int k = -1;
    do {
        ( k, slice v, int f? ) = requests.udict_get_next?(256, k);
        if (f?) {
            slice request = v;
            int min_payment = v~load_coins();
            int validator_reward_share = v~load_uint(14);
            int pool_reward_share = 10000 - validator_reward_share;
            ;; use a random part (prefix of signature),
            ;; so that everyone has a chance to win when min payment and reward share are equal
            int random_part = v.preload_ref().begin_parse().preload_ref().begin_parse().preload_uint(64);
            int sort_key = min_payment << (14 + 64) + pool_reward_share << 64 + random_part;
            builder sort_value = begin_cell()
                .store_uint(k, 256)
                .store_slice(request);
            sorted~udict_set_builder(120 + 14 + 64, sort_key, sort_value);
        }
    } until (~ f?);
    return sorted;
}

(cell, cell, int) decide_on_loan_requests(cell requests, int participate_until) {
    int elected? = ~ config_param(config::next_validators).null?();
    if (elected? | (now() > participate_until)) {
        ;; reject all loans if already elected or there is not enough time for safe participation
        return ( requests, new_dict(), 0 );
    }
    cell accepted = new_dict();
    int ton_balance = get_balance().pair_first();
    int available = ton_balance - fee::root_storage;
    int allocated = 0;
    cell sorted = sort_loan_requests(requests);
    int k = 1 << (120 + 14 + 64);
    do {
        ;; sorted is in ascending order, read from the end
        ( k, slice v, int f? ) = sorted.udict_get_prev?(120 + 14 + 64, k);
        if (f?) {
            int validator_addr = v~load_uint(256);
            slice request = v;
            v~load_coins(); ;; skip min_payment
            v~skip_bits(14); ;; skip validator_reward_share
            int loan_amount = v~load_coins();
            int at_least = loan_amount + fee::one_ton + fee::pool_storage + fee::new_stake_gas_consumption;
            if (available >= at_least) {
                available -= at_least;
                allocated += loan_amount;
                accepted~udict_set(256, validator_addr, request);
                requests~udict_delete?(256, validator_addr);
            }
        }
    } until (~ f?);
    ;; distribute remaining ton amount between accepted requests, when they have enough stake
    k = -1;
    int total_staked = 0;
    do {
        ( k, slice v, int f? ) = accepted.udict_get_next?(256, k);
        if (f?) {
            ( int min_payment
            , int validator_reward_share
            , int loan_amount
            , _
            , int staked_tokens
            , cell new_stake_msg
            ) = unpack_loan_request(v);
            int accrued_amount = muldiv(available, loan_amount, allocated);
            int total_loan_amount = loan_amount + accrued_amount;
            int max_punishment = max_recommended_punishment_for_validator_misbehaviour(total_loan_amount);
            if (staked_tokens >= min_payment + max_punishment) {
                builder request = pack_loan_request(
                    min_payment, validator_reward_share, loan_amount, accrued_amount, staked_tokens, new_stake_msg
                );
                accepted~udict_set_builder(256, k, request);
                total_staked += total_loan_amount;
            } else {
                total_staked += loan_amount;
            }
        }
    } until (~ f?);
    return (requests, accepted, total_staked);
}

() participate(slice s) impure {
    slice ds = get_data().begin_parse();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell wallet_code = ds~load_ref();
    cell rewards_dict = ds~load_dict();
    cell participations = ds~load_dict();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);

    ifnot (query_id) {
        ;; force reply from elector when staking
        query_id = cur_lt();
    }
    ( slice pd, int f? ) = participations.udict_get?(32, round_since);
    int state = null();
    cell requests = new_dict();
    if (f?) {
        state = pd~load_uint(3);
        requests = pd~load_dict();
    }
    ( int participate_since, int participate_until, _, int next_round_until, int stake_held_for ) = participate_times();

    throw_unless(err::unable_to_participate, state == participation::open);
    throw_unless(err::too_soon_to_participate, now() >= participate_since);

    accept_message();

    state = participation::distribution;
    ( requests, cell accepted, int total_staked ) = decide_on_loan_requests(requests, participate_until);
    int current_vset_hash = config_param(config::current_validators).cell_hash();
    int stake_held_until = next_round_until + stake_held_for + 60;
    builder pdb = pack_participation_data(
        state, requests, accepted, new_dict(), new_dict(), total_staked, 0,
        current_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pdb);
    builder body = begin_cell()
        .store_uint(op::process_loan_requests, 32)
        .store_uint(query_id, 64)
        .store_uint(round_since, 32);
    send_msg(false, my_address().to_builder(), null(), body, fee::one_ton, send::pay_gas_separately);

    begin_cell()
        .store_coins(total_staked_tokens)
        .store_coins(total_unstaked_tokens)
        .store_ref(wallet_code)
        .store_dict(rewards_dict)
        .store_dict(participations)
        .store_slice(ds)
        .end_cell()
        .set_data();
}

() process_loan_requests(slice src, slice s) impure {
    slice ds = get_data().begin_parse();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell wallet_code = ds~load_ref();
    cell rewards_dict = ds~load_dict();
    cell participations = ds~load_dict();
    cell root_extension = ds~load_ref();
    cell pool_code = root_extension.begin_parse().preload_ref();
    ds.end_parse();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);

    ( slice pd, int f? ) = participations.udict_get?(32, round_since);
    ( int state
    , cell requests
    , cell accepted
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation_data(pd);

    throw_unless(err::access_denied, equal_slices(src, my_address()));

    accept_message();

    int remain = 255 - 1; ;; keep the last one for continue message
    ;; send new stake message from the pool of accepted loans
    while ((~ dict_empty?(accepted)) & (remain > 0)) {
        ( int validator_addr, slice request, int f? ) = accepted~udict_delete_get_min?(256);
        if (f?) {
            staked~udict_set(256, validator_addr, request);
            builder validator = create_address(chain::base, validator_addr);
            ( builder pool, cell state_init, _ ) = create_pool_address(my_address(), validator, round_since, pool_code);
            request~load_coins(); ;; skip min_payment
            request~skip_bits(14); ;; skip validator_reward_share
            int loan_amount = request~load_coins();
            int accrued_amount = request~load_coins();
            int total_loan_amount = loan_amount + accrued_amount;
            int ton_amount = total_loan_amount + fee::one_ton + fee::pool_storage + fee::new_stake_gas_consumption;
            builder body = begin_cell()
                .store_uint(op::send_new_stake, 32)
                .store_uint(query_id, 64)
                .store_coins(total_loan_amount)
                .store_ref(request~load_ref());
            send_msg(true, pool, state_init, body, ton_amount, send::pay_gas_separately);
            total_staked += total_loan_amount;
            remain -= 1;
        }
    }
    ;; handle possible error thrown from get_vset_times
    ( int round_since, _ ) = get_vset_times(config::current_validators);
    ;; return staked amount of rejected requests
    while ((~ dict_empty?(requests)) & (remain > 0)) {
        ( int validator_addr, slice request, int f? ) = requests~udict_delete_get_min?(256);
        if (f?) {
            builder validator = create_address(chain::base, validator_addr);
            ( builder wallet
            , cell state_init
            , _
            ) = create_wallet_address(validator, my_address(), wallet_code);
            request~load_coins(); ;; skip min_payment
            request~load_uint(14); ;; skip validator_reward_share
            request~load_coins(); ;; skip loan_amount
            request~load_coins(); ;; skip accrued_amount
            int staked_tokens = request~load_coins();
            cell tokens_dict = new_dict();
            tokens_dict~udict_set_builder(32, round_since, begin_cell().store_coins(staked_tokens));
            builder body = begin_cell()
                .store_uint(op::receive_tokens, 32)
                .store_uint(query_id, 64)
                .store_coins(staked_tokens)
                .store_uint(0, 1) ;; skip withdrawal
                .store_dict(tokens_dict)
                .store_uint(0, 1) ;; skip then_send
                .store_builder(create_address(chain::base, validator_addr))
                .store_slice(my_address())
                .store_coins(0)
                .store_uint(0, 1);
            send_msg(true, wallet, state_init, body, fee::one_ton, send::pay_gas_separately);
            remain -= 1;
        }
    }
    ifnot (dict_empty?(requests) & dict_empty?(accepted)) {
        ;; continue sending messages until done
        builder body = begin_cell()
            .store_uint(op::process_loan_requests, 32)
            .store_uint(query_id, 64);
        send_msg(false, my_address().to_builder(), null(), body, fee::one_ton, send::pay_gas_separately);
    } else {
        state = participation::staked;
    }
    if (dict_empty?(requests) & dict_empty?(accepted) & dict_empty?(staked)) {
        ;; no loans accepted, remove empty participation data
        participations~udict_delete?(32, round_since);
    } else {
        builder pdb = pack_participation_data(
            state, requests, accepted, staked, recovering, total_staked, total_recovered,
            current_vset_hash, stake_held_for, stake_held_until
        );
        participations~udict_set_builder(32, round_since, pdb);
    }

    begin_cell()
        .store_coins(total_staked_tokens)
        .store_coins(total_unstaked_tokens)
        .store_ref(wallet_code)
        .store_dict(rewards_dict)
        .store_dict(participations)
        .store_ref(root_extension)
        .end_cell()
        .set_data();
}

() new_stake_rejected(int msg_ton, slice src, slice s) impure {
    slice ds = get_data().begin_parse();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell wallet_code = ds~load_ref();
    cell rewards_dict = ds~load_dict();
    cell participations = ds~load_dict();
    cell root_extension = ds~load_ref();
    cell pool_code = root_extension.begin_parse().preload_ref();
    ds.end_parse();

    int query_id = s~load_uint(64);
    int reason = s~load_uint(32);
    slice validator = s~load_msg_addr();
    int round_since = s~load_uint(32);
    s.end_parse();
    ( _, _, int pool_addr ) = create_pool_address(my_address(), validator.to_builder(), round_since, pool_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::main) & (src_addr == pool_addr));

    accept_message();

    ( builder wallet, cell state_init, _ ) = create_wallet_address(validator.to_builder(), my_address(), wallet_code);
    ( _, int validator_addr ) = parse_std_addr(validator);
    ( slice pd, int f? ) = participations.udict_get?(32, round_since);
    if (f?) {
        ( int state
        , cell requests
        , cell accepted
        , cell staked
        , cell recovering
        , int total_staked
        , int total_recovered
        , int current_vset_hash
        , int stake_held_for
        , int stake_held_until
        ) = unpack_participation_data(pd);
        ( slice request, int e? ) = staked~udict_delete_get?(256, validator_addr);
        if (e?) {
            ( int min_payment, _, _, _, int staked_tokens, _ ) = unpack_loan_request(request);
            total_recovered += msg_ton - fee::one_ton + min_payment;
            int remain = staked_tokens - min_payment;
            cell tokens_dict = new_dict();
            tokens_dict~udict_set_builder(32, round_since, begin_cell().store_coins(remain));
            builder body = begin_cell()
                .store_uint(op::receive_tokens, 32)
                .store_uint(query_id, 64)
                .store_coins(remain)
                .store_uint(0, 1) ;; skip withdrawal
                .store_dict(tokens_dict)
                .store_uint(0, 1) ;; skip then_send
                .store_slice(validator)
                .store_slice(my_address())
                .store_coins(0)
                .store_uint(0, 1);
            send_msg(true, wallet, state_init, body, fee::wallet_storage, send::pay_gas_separately);
            builder pdb = pack_participation_data(
                state, requests, accepted, staked, recovering, total_staked, total_recovered,
                current_vset_hash, stake_held_for, stake_held_until
            );
            participations~udict_set_builder(32, round_since, pdb);
        }
    }

    begin_cell()
        .store_coins(total_staked_tokens)
        .store_coins(total_unstaked_tokens)
        .store_ref(wallet_code)
        .store_dict(rewards_dict)
        .store_dict(participations)
        .store_ref(root_extension)
        .end_cell()
        .set_data();
}

() vset_changed(slice s) impure {
    slice ds = get_data().begin_parse();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell wallet_code = ds~load_ref();
    cell rewards_dict = ds~load_dict();
    cell participations = ds~load_dict();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice pd, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , cell requests
    , cell accepted
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation_data(pd);
    int new_vset_hash = config_param(config::current_validators).cell_hash();

    throw_unless(err::vset_not_changed, new_vset_hash != current_vset_hash);
    throw_unless(err::not_ready_to_change_vset, (state == participation::staked) | (state == participation::validating));

    accept_message();

    if (state == participation::staked) {
        state = participation::validating;
        ( int validators_elected_for, _, _, _ ) = get_election_config();
        stake_held_until = now() + validators_elected_for + stake_held_for + 60;
    } else {
        state = participation::held;
        stake_held_until = now() + stake_held_for + 60;
    }
    builder pdb = pack_participation_data(
        state, requests, accepted, staked, recovering, total_staked, total_recovered,
        new_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pdb);

    begin_cell()
        .store_coins(total_staked_tokens)
        .store_coins(total_unstaked_tokens)
        .store_ref(wallet_code)
        .store_dict(rewards_dict)
        .store_dict(participations)
        .store_slice(ds)
        .end_cell()
        .set_data();
}

() recover(slice s) impure {
    slice ds = get_data().begin_parse();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell wallet_code = ds~load_ref();
    cell rewards_dict = ds~load_dict();
    cell participations = ds~load_dict();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice pd, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , cell requests
    , cell accepted
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation_data(pd);

    throw_unless(err::not_ready_to_recover, state == participation::held);
    throw_unless(err::too_soon_to_recover, now() >= stake_held_until);

    accept_message();

    state = participation::recovering;
    builder pdb = pack_participation_data(
        state, requests, accepted, staked, recovering, total_staked, total_recovered,
        current_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pdb);
    builder body = begin_cell()
        .store_uint(op::process_stakes, 32)
        .store_uint(query_id, 64)
        .store_uint(round_since, 32);
    send_msg(false, my_address().to_builder(), null(), body, fee::one_ton, send::pay_gas_separately);

    begin_cell()
        .store_coins(total_staked_tokens)
        .store_coins(total_unstaked_tokens)
        .store_ref(wallet_code)
        .store_dict(rewards_dict)
        .store_dict(participations)
        .store_slice(ds)
        .end_cell()
        .set_data();
}

() process_stakes(slice src, slice s) impure {
    slice ds = get_data().begin_parse();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell wallet_code = ds~load_ref();
    cell rewards_dict = ds~load_dict();
    cell participations = ds~load_dict();
    cell root_extension = ds~load_ref();
    cell pool_code = root_extension.begin_parse().preload_ref();
    ds.end_parse();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice pd, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , cell requests
    , cell accepted
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation_data(pd);

    throw_unless(err::access_denied, equal_slices(src, my_address()));

    accept_message();

    int remain = 255 - 1; ;; keep the last one for continue message
    ;; send recover stake message from the pool of held stakes
    do {
        ( int validator_addr, slice request, int f? ) = staked~udict_delete_get_min?(256);
        if (f?) {
            recovering~udict_set(256, validator_addr, request);
            builder validator = create_address(chain::base, validator_addr);
            ( builder pool, cell state_init, _ ) = create_pool_address(my_address(), validator, round_since, pool_code);
            builder body = begin_cell()
                .store_uint(op::send_recover_stake, 32)
                .store_uint(query_id, 64);
            send_msg(true, pool, state_init, body, fee::one_ton, send::pay_gas_separately);
            remain -= 1;
        }
        f? = f? & (remain > 0);
    } until (~ f?);
    ifnot (staked.dict_empty?()) {
        ;; continue sending messages until done
        builder body = begin_cell()
            .store_uint(op::process_stakes, 32)
            .store_uint(query_id, 64)
            .store_int(round_since, 32);
        send_msg(false, my_address().to_builder(), null(), body, fee::one_ton, send::pay_gas_separately);
    }

    builder pdb = pack_participation_data(
        state, requests, accepted, staked, recovering, total_staked, total_recovered,
        current_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pdb);

    begin_cell()
        .store_coins(total_staked_tokens)
        .store_coins(total_unstaked_tokens)
        .store_ref(wallet_code)
        .store_dict(rewards_dict)
        .store_dict(participations)
        .store_ref(root_extension)
        .end_cell()
        .set_data();
}

() recover_stake_result(int msg_ton, slice src, slice s) impure {
    slice ds = get_data().begin_parse();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell wallet_code = ds~load_ref();
    cell rewards_dict = ds~load_dict();
    cell participations = ds~load_dict();
    cell root_extension = ds~load_ref();
    ds.end_parse();
    slice res = root_extension.begin_parse();
    cell pool_code = res~load_ref();
    int rewards_size = res~load_uint(10);

    int query_id = s~load_uint(64);
    int ok? = s~load_uint(1);
    slice validator = s~load_msg_addr();
    int round_since = s~load_uint(32);
    s.end_parse();
    ( _, _, int pool_addr ) = create_pool_address(my_address(), validator.to_builder(), round_since, pool_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::main) & (src_addr == pool_addr));

    accept_message();

    ( builder wallet, cell state_init, _ ) = create_wallet_address(validator.to_builder(), my_address(), wallet_code);
    ( _, int validator_addr ) = parse_std_addr(validator);
    ( slice pd, int f? ) = participations.udict_get?(32, round_since);
    if (f?) {
        ( int state
        , cell requests
        , cell accepted
        , cell staked
        , cell recovering
        , int total_staked
        , int total_recovered
        , int current_vset_hash
        , int stake_held_for
        , int stake_held_until
        ) = unpack_participation_data(pd);
        ( slice request, int e? ) = recovering~udict_delete_get?(256, validator_addr);
        if (e?) {
            ( int min_payment
            , int validator_reward_share
            , int loan_amount
            , int accrued_amount
            , int staked_tokens
            , _
            ) = unpack_loan_request(request);
            int recovered = msg_ton - fee::one_ton;
            int reward = recovered - loan_amount - accrued_amount;
            if (reward < 0) {
                ;; when reward is negative, punish the validator first
                int compensation = min(staked_tokens, - reward);
                staked_tokens -= compensation;
                reward += compensation;
                if (reward < 0) {
                    ;; then subtract the rest of the punishment from recovered amount
                    ;; This must not happen yet it is considered for the case that the validator is punished more than
                    ;; maximum punishable, or funds are not returned by the elector.
                    ;; This has a destructive effect after consolidation and reward distribution.
                    total_recovered += loan_amount + accrued_amount + reward;
                    total_staked_tokens += reward;
                } else {
                    int pool_reward_share = 10000 - validator_reward_share;
                    int pool_reward = max(min_payment, muldiv(reward, pool_reward_share, 10000));
                    int withdrawable = min(staked_tokens, pool_reward);
                    staked_tokens -= withdrawable;
                    total_recovered += loan_amount + accrued_amount + withdrawable;
                }
            } else {
                int pool_reward_share = 10000 - validator_reward_share;
                int pool_reward = max(min_payment, muldiv(reward, pool_reward_share, 10000));
                int validator_reward = reward - pool_reward;
                staked_tokens += validator_reward;
                total_recovered += loan_amount + accrued_amount + pool_reward;
                total_staked_tokens += reward;
            }
            if (staked_tokens > 0) {
                cell tokens_dict = new_dict();
                tokens_dict~udict_set_builder(32, round_since, begin_cell().store_coins(staked_tokens));
                builder body = begin_cell()
                    .store_uint(op::receive_tokens, 32)
                    .store_uint(query_id, 64)
                    .store_coins(staked_tokens)
                    .store_uint(0, 1) ;; skip withdrawal
                    .store_dict(tokens_dict)
                    .store_uint(0, 1) ;; skip then_send
                    .store_slice(validator)
                    .store_slice(my_address())
                    .store_coins(0)
                    .store_uint(0, 1);
                send_msg(true, wallet, state_init, body, fee::wallet_storage, send::pay_gas_separately);
            }

            if (dict_empty?(recovering) & (total_recovered >= total_staked)) {
                ;; todo: instead, add to total_ton
                _ = participations~udict_delete?(32, round_since);
                builder reward_data = begin_cell()
                    .store_coins(total_staked)
                    .store_coins(total_recovered);
                rewards_dict~udict_set_builder(32, round_since, reward_data);
                if (rewards_size == 1023) {
                    ( _, _, _ ) = rewards_dict~udict_delete_get_min?(32);
                } else {
                    rewards_size += 1;
                    root_extension = begin_cell()
                        .store_ref(pool_code)
                        .store_uint(rewards_size, 10)
                        .store_slice(res)
                        .end_cell();
                }
            } else {
                builder pdb = pack_participation_data(
                    state, requests, accepted, staked, recovering, total_staked, total_recovered,
                    current_vset_hash, stake_held_for, stake_held_until
                );
                participations~udict_set_builder(32, round_since, pdb);
            }

            begin_cell()
                .store_coins(total_staked_tokens)
                .store_coins(total_unstaked_tokens)
                .store_ref(wallet_code)
                .store_dict(rewards_dict)
                .store_dict(participations)
                .store_ref(root_extension)
                .end_cell()
                .set_data();
        }
    }
}

() handle_bounced_message(slice src, slice s) impure {
    int op = s~load_uint(32);

    if (op == op::receive_tokens) {
        ;; wallet failed to receive
        ;; this must not happen, and since round may have changed before receiving bounced message,
        ;; it's impractical to determine total_next must be reduced or total_later.
        ;; ignored, but always check that there's no possible way for `receive` op to wallet to fail.
    }

    if (op == op::take_wallet_address) {
        ;; not important, ignore it
    }

    if (op == op::send_new_stake) {
        ;; handle like new_stake_rejected
    }

    if (op == op::send_recover_stake) {
        ;; might happen if new stake was rejected previously
        ;; just accept coins
    }
}

() recv_internal(int msg_ton, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice src = cs~load_msg_addr();
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_dict(); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; used for fee calculations

    int op = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }

    if (flags & 1) {
        handle_bounced_message(src, in_msg_body);
        return ();
    }

    if (op == 0) { ;; simple transfer, convert to stake request
        simple_stake(msg_ton, fwd_fee, src);
        return ();
    }

    if (op == op::stake_ton) { ;; stake TON
        advanced_stake(msg_ton, fwd_fee, src, in_msg_body);
        return ();
    }

    if (op == op::unstake_reserve) { ;; reserve TON for later unstake
        unstake_reserve(msg_ton, src, in_msg_body);
        return ();
    }

    if (op == op::withdraw_ton) {
        withdraw_ton(msg_ton, fwd_fee, src, in_msg_body);
        return ();
    }

    if (op == op::provide_wallet_address) { ;; return wallet address
        provide_wallet_address(msg_ton, fwd_fee, src, in_msg_body);
        return ();
    }

    if (op == op::save_loan_request) { ;; a validator requests a loan
        save_loan_request(msg_ton, src, in_msg_body);
        return ();
    }

    if (op == op::participate) { ;; participate in election
        participate(in_msg_body);
        return ();
    }

    if (op == op::process_loan_requests) { ;; allocate pools or return staked amounts
        process_loan_requests(src, in_msg_body);
        return ();
    }

    if (op == op::new_stake_rejected) { ;; new stake rejected by elector
        new_stake_rejected(msg_ton, src, in_msg_body);
        return ();
    }

    if (op == op::recover) { ;; recover stakes from pools if it's time
        recover(in_msg_body);
        return ();
    }

    if (op == op::process_stakes) { ;; send recover stake to pools
        process_stakes(src, in_msg_body);
        return ();
    }

    if (op == op::recover_stake_result) { ;; result of recover stake
        recover_stake_result(msg_ton, src, in_msg_body);
        return ();
    }

    if (op == op::top_up) { ;; top up root's TON balance
        ;; do nothing
        return ();
    }

    throw(err::unknown_op);
}

() recv_external(slice in_msg_body) impure {
    int op = in_msg_body~load_uint(32);

    if (op == op::participate) { ;; participate in election
        participate(in_msg_body);
        return ();
    }

    if (op == op::recover) { ;; recover stakes from pools if it's time
        recover(in_msg_body);
        return ();
    }
}

;;
;; get methods
;;

(int, int, int, cell, cell, cell) get_root_state() method_id {
    slice ds = get_data().begin_parse();
    int total_ton = ds~load_coins();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell participations = ds~load_dict();
    cell wallet_code = ds~load_ref();
    cell pool_code = ds~load_ref();
    cell root_extension = ds~load_ref();
    ds.end_parse();
    slice es = root_extension.begin_parse();
    cell rewards_history = es~load_dict();
    cell content = es~load_ref();
    es.end_parse();

    return ( total_ton, total_staked_tokens, total_unstaked_tokens, participations, rewards_history, pool_code );
}

(int, int, slice, cell, cell) get_jetton_data() method_id {
    slice ds = get_data().begin_parse();
    int total_ton = ds~load_coins();
    int total_staked_tokens = ds~load_coins();
    int total_unstaked_tokens = ds~load_coins();
    cell participations = ds~load_dict();
    cell wallet_code = ds~load_ref();
    cell pool_code = ds~load_ref();
    cell root_extension = ds~load_ref();
    ds.end_parse();
    slice rs = root_extension.begin_parse();
    cell rewards_history = rs~load_dict();
    cell content = ds~load_ref();
    rs.end_parse();

    return ( total_staked_tokens + total_unstaked_tokens, -1, address::empty, content, wallet_code );
}

slice get_wallet_address(slice owner) method_id {
    slice ds = get_data().begin_parse();
    ds~load_coins();
    ds~load_coins();
    ds~load_coins();
    ds~load_dict();
    cell wallet_code = ds~load_ref();

    ( int owner_wc, _ ) = parse_std_addr(owner);

    throw_unless(err::only_basechain_allowed, owner_wc == chain::base);

    ( builder wallet, _, _ ) = create_wallet_address(owner.to_builder(), my_address(), wallet_code);

    return wallet.end_cell().begin_parse();
}

slice get_pool_address(slice validator, int round_since) method_id {
    slice ds = get_data().begin_parse();
    ds~load_coins();
    ds~load_coins();
    ds~load_coins();
    ds~load_dict();
    ds~load_ref();
    cell pool_code = ds~load_ref();

    ( int validator_wc, _ ) = parse_std_addr(validator);

    throw_unless(err::only_basechain_allowed, validator_wc == chain::base);

    ( builder pool, _, _ ) = create_pool_address(my_address(), validator.to_builder(), round_since, pool_code);

    return pool.end_cell().begin_parse();
}

(int, int, int) get_fees() method_id {
    return
        ( fee::root_storage
        , fee::wallet_storage
        , fee::pool_storage
        );
}

int get_max_punishment(int stake) method_id {
    return max_recommended_punishment_for_validator_misbehaviour(stake);
}
