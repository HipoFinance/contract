#include "imports/utils.fc";

() save_data
    ( slice owner
    , slice root
    , int staked_tokens
    , int unstaked_tokens
    , int withdrawal_incentive
    , cell wallet_code
    ) impure {
    begin_cell()
        .store_slice(owner)
        .store_slice(root)
        .store_coins(staked_tokens)
        .store_coins(unstaked_tokens)
        .store_coins(withdrawal_incentive)
        .store_ref(wallet_code)
        .end_cell()
        .set_data();
}

(slice, slice, int, int, int, cell) load_data() impure {
    slice ds = get_data().begin_parse();
    slice owner = ds~load_msg_addr();
    slice root = ds~load_msg_addr();
    int staked_tokens = ds~load_coins();
    int unstaked_tokens = ds~load_coins();
    int withdrawal_incentive = ds~load_coins();
    cell wallet_code = ds~load_ref();
    ds.end_parse();
    return ( owner, root, staked_tokens, unstaked_tokens, withdrawal_incentive, wallet_code );
}

() receive_tokens(int msg_ton, int fwd_fee, slice src, slice s) impure {
    ( slice owner
    , slice root
    , int staked_tokens
    , int unstaked_tokens
    , int withdrawal_incentive
    , cell wallet_code
    ) = load_data();

    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    slice sender = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    int forward_ton_amount = s~load_coins();
    slice forward_payload = s;

    int allowed? = equal_slices(src, root);
    ifnot (allowed?) {
        ( _, _, int wallet_addr ) = create_wallet_address(sender.to_builder(), root, wallet_code);
        ( int src_wc, int src_addr ) = parse_std_addr(src);
        allowed? = (src_wc == chain::base) & (src_addr == wallet_addr);
    }

    throw_unless(err::access_denied, allowed?);

    staked_tokens += tokens;

    raw_reserve(fee::wallet_storage + withdrawal_incentive, reserve::exact);

    if (forward_ton_amount) {
        builder body = begin_cell()
            .store_uint(op::transfer_notification, 32)
            .store_uint(query_id, 64)
            .store_coins(tokens)
            .store_slice(sender)
            .store_slice(forward_payload);
        send_msg(false, owner.to_builder(), null(), body, forward_ton_amount, send::pay_gas_separately);
    }

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, return_excess.to_builder(), null(), excess, 0, send::remaining_balance + send::ignore_errors);

    save_data(owner, root, staked_tokens, unstaked_tokens, withdrawal_incentive, wallet_code);
}

() send_tokens(int msg_ton, int fwd_fee, slice src, slice s) impure {
    ( slice owner
    , slice root
    , int staked_tokens
    , int unstaked_tokens
    , int withdrawal_incentive
    , cell wallet_code
    ) = load_data();

    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    slice recipient = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    s~load_maybe_ref(); ;; skip custom_payload
    int forward_ton_amount = s~load_coins();
    slice forward_payload = s;
    s~skip_bits(1); ;; check either field

    if (return_excess.preload_uint(2) == 0) {
        return_excess = src;
    }

    ( int recipient_wc, _ ) = parse_std_addr(recipient);
    int fwd_count = forward_ton_amount ? 2 : 1;
    int min_ton =
            forward_ton_amount +
            ;; 3 messages: wallet1->wallet2, wallet2->owner, wallet2->return (optional)
            fwd_count * fwd_fee +
            2 * fee::wallet_gas_consumption +
            fee::wallet_storage;

    throw_unless(err::access_denied, equal_slices(src, owner));
    throw_unless(err::only_basechain_allowed, recipient_wc == chain::base);
    throw_unless(err::receiver_is_sender, ~ equal_slices(recipient, owner));
    throw_unless(err::insufficient_fee, msg_ton >= min_ton);
    throw_unless(err::insufficient_funds, (tokens > 0) & (tokens <= staked_tokens));

    staked_tokens -= tokens;

    ( builder wallet
    , cell state_init
    , _
    ) = create_wallet_address(recipient.to_builder(), root, wallet_code);
    builder body = begin_cell()
        .store_uint(op::receive_tokens, 32)
        .store_uint(query_id, 64)
        .store_coins(tokens)
        .store_slice(owner)
        .store_slice(return_excess)
        .store_coins(forward_ton_amount)
        .store_forward_payload(forward_payload);
    send_msg(true, wallet, state_init, body, 0, send::remaining_value);

    save_data(owner, root, staked_tokens, unstaked_tokens, withdrawal_incentive, wallet_code);
}

() unstake_tokens(int msg_ton, int fwd_fee, slice src, slice s) impure {
    ( slice owner
    , slice root
    , int staked_tokens
    , int unstaked_tokens
    , _
    , cell wallet_code
    ) = load_data();

    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    slice return_excess = s~load_msg_addr();
    cell custom_payload = s~load_maybe_ref();
    s.end_parse();

    int withdrawal_incentive = 0;
    ifnot (custom_payload.null?()) {
        slice ps = custom_payload.begin_parse();
        withdrawal_incentive = ps~load_coins();
        ps.end_parse();
    }
    if (return_excess.preload_uint(2) == 0) {
        return_excess = src;
    }

    int min_ton =
            ;; 2 messages: wallet->root, wallet->return (optional)
            fwd_fee +
            fee::wallet_gas_consumption +
            withdrawal_incentive;

    throw_unless(err::access_denied, equal_slices(src, owner));
    throw_unless(err::insufficient_fee, msg_ton >= min_ton);
    throw_unless(err::insufficient_funds, (tokens > 0) & (tokens <= staked_tokens));

    staked_tokens -= tokens;
    unstaked_tokens += tokens;

    raw_reserve(fee::wallet_storage + withdrawal_incentive, reserve::exact);

    builder body = begin_cell()
        .store_uint(op::unstake_reserve, 32)
        .store_uint(query_id, 64)
        .store_coins(tokens)
        .store_slice(owner)
        .store_slice(return_excess);
    send_msg(true, root.to_builder(), null(), body, 0, send::remaining_balance);

    save_data(owner, root, staked_tokens, unstaked_tokens, withdrawal_incentive, wallet_code);
}

() release_ton(int msg_ton, int fwd_fee, slice src, slice s) impure {
    ( slice owner
    , slice root
    , int staked_tokens
    , int unstaked_tokens
    , int withdrawal_incentive
    , cell wallet_code
    ) = load_data();

    int query_id = s~load_uint(64);
    slice return_excess = s~load_msg_addr();
    s.end_parse();

    if (return_excess.preload_uint(2) == 0) {
        return_excess = src;
    }

    int min_ton =
        ;; 3 messages: wallet->root, root->owner, root->return (optional)
        ;;         or: wallet->root, root->wallet, wallet->return (optional)
        2 * fwd_fee +
        2 * fee::wallet_gas_consumption;

    throw_unless(err::insufficient_fee, msg_ton >= min_ton);
    throw_unless(err::insufficient_funds, unstaked_tokens > 0);

    builder body = begin_cell()
        .store_uint(op::withdraw_ton, 32)
        .store_uint(query_id, 64)
        .store_coins(unstaked_tokens)
        .store_coins(withdrawal_incentive)
        .store_slice(owner)
        .store_slice(return_excess);
    send_msg(true, root.to_builder(), null(), body, withdrawal_incentive, send::remaining_value);

    save_data(owner, root, staked_tokens, 0, 0, wallet_code);
}

() withdraw_failed(int msg_ton, int fwd_fee, slice src, slice s) impure {
    ( slice owner
    , slice root
    , int staked_tokens
    , int unstaked_tokens
    , int withdrawal_incentive
    , cell wallet_code
    ) = load_data();

    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    int incentive = s~load_coins();
    slice return_excess = s~load_msg_addr();
    s.end_parse();

    throw_unless(err::access_denied, equal_slices(src, root));

    unstaked_tokens += tokens;
    withdrawal_incentive = incentive;

    raw_reserve(fee::wallet_storage + withdrawal_incentive, reserve::at_most);

    builder excess = begin_cell()
        .store_uint(op::release_failed, 32)
        .store_uint(query_id, 64);
    send_msg(false, return_excess.to_builder(), null(), excess, 0, send::remaining_balance + send::ignore_errors);

    save_data(owner, root, staked_tokens, unstaked_tokens, withdrawal_incentive, wallet_code);
}

() on_bounce(slice src, slice s) impure {
    ;; this should not happen but in a rare case of a bounce (e.g. a frozen account), at least recover tokens

    ( slice owner
    , slice root
    , int staked_tokens
    , int unstaked_tokens
    , int withdrawal_incentive
    , cell wallet_code
    ) = load_data();

    int op = s~load_uint(32);
    int query_id = s~load_uint(64);
    int tokens = s~load_coins();

    if ((op == op::receive_tokens) | (op == op::unstake_reserve)) {
        staked_tokens += tokens;
    }

    if (op == op::withdraw_ton) {
        unstaked_tokens += tokens;
        ;; cannot recover withdrawal_incentive, skip it
    }

    ;; return excess gas to owner which is usually the original sender
    builder body = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, owner.to_builder(), null(), body, 0, send::remaining_value + send::ignore_errors);

    save_data(owner, root, staked_tokens, unstaked_tokens, withdrawal_incentive, wallet_code);
}

() recv_internal(int msg_ton, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice src = cs~load_msg_addr();
    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_dict(); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; used for fee calculations

    int op = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }

    if (flags & 1) {
        on_bounce(src, in_msg_body);
        return ();
    }

    if (op == op::receive_tokens) {
        receive_tokens(msg_ton, fwd_fee, src, in_msg_body);
        return ();
    }

    if (op == op::send_tokens) {
        send_tokens(msg_ton, fwd_fee, src, in_msg_body);
        return ();
    }

    if (op == op::unstake_tokens) {
        unstake_tokens(msg_ton, fwd_fee, src, in_msg_body);
        return ();
    }

    if (op == op::release_ton) {
        release_ton(msg_ton, fwd_fee, src, in_msg_body);
        return ();
    }

    if (op == op::withdraw_failed) {
        withdraw_failed(msg_ton, fwd_fee, src, in_msg_body);
    }

    if (op == op::top_up) {
        ;; top up TON balance, do nothing
        return ();
    }

    throw(err::unknown_op);
}

;;
;; get methods
;;

(int, int, int) get_wallet_state() method_id {
    ( _
    , _
    , int staked_tokens
    , int unstaked_tokens
    , int withdrawal_incentive
    , _
    ) = load_data();

    return ( staked_tokens, unstaked_tokens, withdrawal_incentive );
}

(int, slice, slice, cell) get_wallet_data() method_id {
    ( slice owner
    , slice root
    , int staked_tokens
    , _
    , _
    , cell wallet_code
    ) = load_data();

    return ( staked_tokens, owner, root, wallet_code );
}
