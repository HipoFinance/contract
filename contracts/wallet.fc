#include "imports/utils.fc";

global slice owner;
global slice parent;
global int tokens;
global cell staking;
global int unstaking;

() save_data() impure inline_ref {
    begin_cell()
        .store_slice(owner)
        .store_slice(parent)
        .store_coins(tokens)
        .store_dict(staking)
        .store_coins(unstaking)
        .end_cell()
        .set_data();
}

() load_data() impure inline_ref {
    slice ds = get_data().begin_parse();
    owner = ds~load_msg_addr();
    parent = ds~load_msg_addr();
    tokens = ds~load_coins();
    staking = ds~load_dict();
    unstaking = ds~load_coins();
    ds.end_parse();
}

() send_tokens(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int amount = s~load_coins();
    slice recipient = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    s~load_maybe_ref(); ;; skip custom_payload
    int forward_ton_amount = s~load_coins();
    slice forward_payload = s;
    s~skip_bits(1); ;; check either field

    ifnot return_excess.preload_uint(2) {
        return_excess = src;
    }

    ( int recipient_wc, _ ) = parse_std_addr(recipient);
    ( builder wallet, cell state_init, _ ) = create_wallet_address(recipient.to_builder(), parent, my_code());
    int min_ton = send_tokens_fee(forward_ton_amount, s);
    int incoming_ton = get_incoming_value().pair_first();
    int ton_balance = get_balance().pair_first();

    throw_unless(err::access_denied, equal_slice_bits(src, owner));
    throw_unless(err::only_basechain_allowed, recipient_wc == chain::base);
    throw_unless(err::receiver_is_sender, ~ equal_slice_bits(recipient, owner));
    throw_unless(err::insufficient_fee, (ton_balance >= incoming_ton) & (incoming_ton >= min_ton));
    throw_unless(err::insufficient_funds, (amount > 0) & (amount <= tokens));

    tokens -= amount;

    builder receive = begin_cell()
        .store_uint(op::receive_tokens, 32)
        .store_uint(query_id, 64)
        .store_coins(amount)
        .store_slice(owner)
        .store_slice(return_excess)
        .store_coins(forward_ton_amount)
        .store_slice(forward_payload);
    send_msg(true, wallet, state_init, receive, 0, send::remaining_value);

    save_data();
}

() receive_tokens(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int amount = s~load_coins();
    slice sender = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    int forward_ton_amount = s~load_coins();
    slice forward_payload = s;

    ( _, _, int wallet_addr ) = create_wallet_address(sender.to_builder(), parent, my_code());
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::base) & (src_addr == wallet_addr));

    tokens += amount;

    int incoming_ton = get_incoming_value().pair_first();
    int ton_balance = get_balance().pair_first();
    int ton_balance_before_msg = ton_balance - incoming_ton;
    int reserve_balance = max(ton_balance_before_msg, wallet_storage_fee());
    raw_reserve(reserve_balance, reserve::at_most);

    if forward_ton_amount {
        builder notification = begin_cell()
            .store_uint(op::transfer_notification, 32)
            .store_uint(query_id, 64)
            .store_coins(amount)
            .store_slice(sender)
            .store_slice(forward_payload);
        send_msg(false, owner.to_builder(), null(), notification, forward_ton_amount, send::pay_gas_separately);
    }

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, return_excess.to_builder(), null(), excess, 0, send::unreserved_balance + send::ignore_errors);

    save_data();
}

() tokens_minted(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int amount = s~load_coins();
    int coins = s~load_coins();
    s~load_msg_addr(); ;; skip owner address
    int round_since = s~load_uint(32);
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, parent));

    tokens += amount;

    if round_since {
        ( slice v, _ ) = staking~udict_delete_get?(32, round_since);
        int staking_coins = v~load_coins();
        v.end_parse();
        staking_coins -= coins;
        if staking_coins {
            staking~udict_set_builder(32, round_since, begin_cell().store_coins(staking_coins));
        }
    }

    int incoming_ton = get_incoming_value().pair_first();
    int ton_balance = get_balance().pair_first();
    int ton_balance_before_msg = ton_balance - incoming_ton;
    int reserve_balance = max(ton_balance_before_msg, wallet_storage_fee());
    raw_reserve(reserve_balance, reserve::at_most);

    builder notification = begin_cell()
        .store_uint(op::stake_notification, 32)
        .store_uint(query_id, 64)
        .store_coins(amount);
    send_msg(false, owner.to_builder(), null(), notification, 0, send::unreserved_balance + send::ignore_errors);

    save_data();
}

() save_coins(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int coins = s~load_coins();
    s~load_msg_addr(); ;; skip owner address
    int round_since = s~load_uint(32);
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, parent));

    ( slice v, int f? ) = staking.udict_get?(32, round_since);
    if f? {
        coins += v~load_coins();
        v.end_parse();
    }
    staking~udict_set_builder(32, round_since, begin_cell().store_coins(coins));

    save_data();
}

() unstake_tokens(slice src, slice s) impure inline_ref {
    int query_id = s~load_uint(64);
    int amount = s~load_coins();
    int ownership_assigned_amount = s~load_coins();
    s.end_parse();

    ( int unstake_fee, _ ) = unstake_tokens_fee(ownership_assigned_amount);
    int incoming_ton = get_incoming_value().pair_first();
    int ton_balance = get_balance().pair_first();

    throw_unless(err::access_denied, equal_slice_bits(src, owner));
    throw_unless(err::insufficient_fee, (ton_balance >= incoming_ton) & (incoming_ton >= unstake_fee));
    throw_unless(err::insufficient_funds, (amount > 0) & (amount <= tokens));

    tokens -= amount;
    unstaking += amount;

    builder reserve = begin_cell()
        .store_uint(op::proxy_reserve_tokens, 32)
        .store_uint(query_id, 64)
        .store_coins(amount)
        .store_slice(owner)
        .store_coins(ownership_assigned_amount);
    send_msg(true, parent.to_builder(), null(), reserve, 0, send::remaining_value);

    save_data();
}

() unstake_all_tokens(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, parent));

    slice s = begin_cell()
        .store_uint(query_id, 64)
        .store_coins(tokens)
        .store_coins(0)
        .end_cell()
        .begin_parse();

    unstake_tokens(owner, s);
}

() rollback_unstake(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int amount = s~load_coins();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, parent));

    tokens += amount;
    unstaking -= amount;

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, owner.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    save_data();
}

() tokens_burned(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int amount = s~load_coins();
    int coins = s~load_coins();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, parent));

    unstaking -= amount;

    int incoming_ton = get_incoming_value().pair_first();
    int ton_balance = get_balance().pair_first();
    int ton_balance_before_msg = ton_balance - incoming_ton;
    int reserve_balance = max(ton_balance_before_msg, wallet_storage_fee());
    raw_reserve(reserve_balance, reserve::at_most);

    builder notification = begin_cell()
        .store_uint(op::withdrawal_notification, 32)
        .store_uint(query_id, 64)
        .store_coins(amount)
        .store_coins(coins);
    send_msg(false, owner.to_builder(), null(), notification, coins, send::unreserved_balance + send::ignore_errors);

    save_data();
}

() upgrade_wallet(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    s.end_parse();

    int min_ton = upgrade_wallet_fee();
    int incoming_ton = get_incoming_value().pair_first();
    int ton_balance = get_balance().pair_first();

    throw_unless(err::access_denied, equal_slice_bits(src, owner) | equal_slice_bits(src, parent));
    throw_unless(err::insufficient_fee, (ton_balance >= incoming_ton) & (incoming_ton >= min_ton));

    builder migrate = begin_cell()
        .store_uint(op::proxy_migrate_wallet, 32)
        .store_uint(query_id, 64)
        .store_coins(tokens)
        .store_slice(owner);
    send_msg(true, parent.to_builder(), null(), migrate, 0, send::remaining_value);

    tokens = 0;

    save_data();
}

() merge_wallet(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int new_tokens = s~load_coins();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, parent));

    tokens += new_tokens;

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, owner.to_builder(), null(), excess, 0, send::remaining_value);

    save_data();
}

() withdraw_surplus(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    slice return_excess = s~load_msg_addr();
    s.end_parse();

    ifnot return_excess.preload_uint(2) {
        return_excess = src;
    }

    throw_unless(err::access_denied, equal_slice_bits(src, owner));

    raw_reserve(wallet_storage_fee(), reserve::exact);

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, return_excess.to_builder(), null(), excess, 0, send::unreserved_balance + send::ignore_errors);
}

() withdraw_jettons(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    slice child_wallet = s~load_msg_addr();
    int tokens = s~load_coins();
    cell custom_payload = s~load_maybe_ref();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, owner));

    builder send = begin_cell()
        .store_uint(op::send_tokens, 32)
        .store_uint(query_id, 64)
        .store_coins(tokens)
        .store_slice(owner)
        .store_slice(owner)
        .store_maybe_ref(custom_payload)
        .store_coins(0)
        .store_int(false, 1);
    send_msg(true, child_wallet.to_builder(), null(), send, 0, send::remaining_value);
}

() on_bounce(slice src, slice s) impure inline {
    ;; this should not happen but in a rare case of a bounce (e.g. a frozen account), at least recover tokens

    s~load_uint(32);
    int op = s~load_uint(32);
    int query_id = s~load_uint(64);

    if op == op::receive_tokens {
        int amount = s~load_coins();
        tokens += amount;
    }

    if op == op::proxy_reserve_tokens {
        int amount = s~load_coins();
        tokens += amount;
        unstaking -= amount;
    }

    if op == op::proxy_migrate_wallet {
        int amount = s~load_coins();
        tokens += amount;
    }

    if op == op::send_tokens {
        ;; do nothing
    }

    ;; return excess gas to owner which is usually the original sender
    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, owner.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    save_data();
}

() recv_internal(cell in_msg_full, slice s) impure {
    load_data();

    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice src = cs~load_msg_addr();

    if flags & 1 {
        return on_bounce(src, s);
    }

    int op = s~load_uint(32);

    if op == op::send_tokens {
        return send_tokens(src, s);
    }

    if op == op::receive_tokens {
        return receive_tokens(src, s);
    }

    if op == op::tokens_minted {
        return tokens_minted(src, s);
    }

    if op == op::save_coins {
        return save_coins(src, s);
    }

    if op == op::unstake_tokens {
        return unstake_tokens(src, s);
    }

    if op == op::unstake_all_tokens {
        return unstake_all_tokens(src, s);
    }

    if op == op::rollback_unstake {
        return rollback_unstake(src, s);
    }

    if op == op::tokens_burned {
        return tokens_burned(src, s);
    }

    if op == op::upgrade_wallet {
        return upgrade_wallet(src, s);
    }

    if op == op::merge_wallet {
        return merge_wallet(src, s);
    }

    if op == op::withdraw_surplus {
        return withdraw_surplus(src, s);
    }

    if op == op::withdraw_jettons {
        return withdraw_jettons(src, s);
    }

    if op == op::top_up {
        return (); ;; top up TON balance, do nothing
    }

    throw(err::invalid_op);
}

;;
;; get methods
;;

(int, slice, slice, cell) get_wallet_data() method_id {
    load_data();

    return ( tokens, owner, parent, my_code() );
}

(int, cell, int) get_wallet_state() method_id {
    load_data();

    return ( tokens, staking, unstaking );
}

(int, int, int) get_wallet_fees() method_id {
    ( int unstake_fee, _) = unstake_tokens_fee(0);
    int balance = get_balance().pair_first();
    int storage_fee = wallet_storage_fee();
    return
        ( unstake_fee
        , storage_fee
        , balance
        );
}
