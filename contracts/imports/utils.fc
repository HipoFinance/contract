() send_msg(int flags, builder dst, int coins, cell body, int mode) impure {
    ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    ;;   src:MsgAddress dest:MsgAddressInt
    ;;   value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
    ;;   created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
    ;; message$_ {X:Type} info:CommonMsgInfoRelaxed
    ;;   init:(Maybe (Either StateInit ^StateInit))
    ;;   body:(Either X ^X) = MessageRelaxed X;
    cell msg = begin_cell()
        .store_uint(flags, 6)
        .store_builder(dst)
        .store_coins(coins)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, mode);
}

() send_si_msg(int flags, builder dst, int coins, cell state_init, cell body, int mode) impure {
    ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    ;;   src:MsgAddress dest:MsgAddressInt
    ;;   value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
    ;;   created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
    ;; message$_ {X:Type} info:CommonMsgInfoRelaxed
    ;;   init:(Maybe (Either StateInit ^StateInit))
    ;;   body:(Either X ^X) = MessageRelaxed X;
    cell msg = begin_cell()
        .store_uint(flags, 6)
        .store_builder(dst)
        .store_coins(coins)
        .store_uint(2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_ref(state_init)
        .store_maybe_ref(body)
        .end_cell();
    send_raw_message(msg, mode);
}

cell create_wallet_data(slice owner, slice root, cell wallet_code) {
    return begin_cell()
        .store_coins(0) ;; active balance
        .store_coins(0) ;; next balance
        .store_coins(0) ;; later balance
        .store_uint(0, 32) ;; round
        .store_slice(owner)
        .store_slice(root)
        .store_ref(wallet_code)
        .end_cell();
}

cell create_state_init(cell code, cell data) {
    ;; _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)
    ;;   code:(Maybe ^Cell) data:(Maybe ^Cell)
    ;;   library:(HashmapE 256 SimpleLib) = StateInit;
    return begin_cell()
        .store_uint(6, 5) ;; 00110
        .store_ref(code)
        .store_ref(data)
        .end_cell();
}

builder create_address(int wc, int address) {
    ;; addr_std$10 anycast:(Maybe Anycast)
    ;;   workchain_id:int8 address:bits256  = MsgAddressInt;
    return begin_cell()
        .store_uint(4, 3) ;; 100
        .store_uint(wc, 8)
        .store_uint(address, 256);
}

(int, int, int, int) get_election_config(cell c) impure {
    ;; _ validators_elected_for:uint32 elections_start_before:uint32
    ;;   elections_end_before:uint32 stake_held_for:uint32
    ;;   = ConfigParam 15;
    slice cs = c.begin_parse();
    return (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
}

(int, int) get_vset_times(cell c) impure {
    ;; validators_ext#12 utime_since:uint32 utime_until:uint32
    ;;   total:(## 16) main:(## 16) { main <= total } { main >= 1 }
    ;;   total_weight:uint64 list:(HashmapE 16 ValidatorDescr) = ValidatorSet;
    slice cs = c.begin_parse();
    throw_unless(err::unexpected_validator_set_format, cs~load_uint(8) == 0x12);
    return (cs~load_uint(32), cs~load_uint(32));
}

(int, int, int, int, int) update_round(int active, int next, int later, int round) impure {
    (int utime_since, int utime_until) = get_vset_times(config_param(34));
    if (round & (round != utime_since)) { ;; at least one round has passed
        (int prev_utime_since, _) = get_vset_times(config_param(32));
        if (round != prev_utime_since) { ;; more than one round has passed
            active += next + later;
            next = later = 0;
        } else { ;; only one round has passed
            active += next;
            next = later;
            later = 0;
        }
    }
    return (active, next, later, utime_since, utime_until);
}

(int, int) update_next_or_later(int next, int later, int amount, int utime_until) impure {
    (_, int elections_start_before, _, _) = get_election_config(config_param(15));
    if (now() < utime_until - elections_start_before) {
        return (next + amount, later);
    } else {
        return (next, later + amount);
    }
}
