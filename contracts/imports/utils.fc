#include "stdlib.fc";
#include "constants.fc";

(slice, int) load_varint16(slice s) asm( -> 1 0) "LDVARINT16";
builder store_varint16(builder b, int x) asm "STVARINT16";

builder store_state_init(builder b, cell state_init) {
    return state_init.null?()
        ? b.store_uint(0, 1)
        : b.store_uint(2 + 1, 1 + 1).store_ref(state_init);
}

builder store_body(builder b, builder body) {
    return body.builder_bits() <= 518
        ? b.store_uint(0, 1).store_builder(body)
        : b.store_maybe_ref(body.end_cell());
}

() send_msg(int bounceable?, builder dst, cell state_init, builder body, int coins, int mode) impure {
    ;; int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
    ;;   src:MsgAddress dest:MsgAddressInt
    ;;   value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
    ;;   created_lt:uint64 created_at:uint32 = CommonMsgInfoRelaxed;
    ;; message$_ {X:Type} info:CommonMsgInfoRelaxed
    ;;   init:(Maybe (Either StateInit ^StateInit))
    ;;   body:(Either X ^X) = MessageRelaxed X;
    cell msg = begin_cell()
        .store_uint(bounceable? ? 0x18 : 0x10, 6) ;; 011000 or 010000
        .store_builder(dst)
        .store_coins(coins)
        .store_uint(0, 1 + 4 + 4 + 64 + 32)
        .store_state_init(state_init)
        .store_body(body)
        .end_cell();
    send_raw_message(msg, mode);
}

(int, int) get_elector() {
    ;; _ elector_addr:bits256 = ConfigParam 1;
    return (chain::main, config_param(config::elector_address).begin_parse().preload_uint(256));
}

(int, int, int, int) get_election_config() impure {
    ;; _ validators_elected_for:uint32 elections_start_before:uint32
    ;;   elections_end_before:uint32 stake_held_for:uint32
    ;;   = ConfigParam 15;
    slice cs = config_param(config::election).begin_parse();
    return (cs~load_uint(32), cs~load_uint(32), cs~load_uint(32), cs~load_uint(32));
}

(int, int, int, int) get_stake_config() impure {
    ;; _ min_stake:Grams max_stake:Grams min_total_stake:Grams max_stake_factor:uint32 = ConfigParam 17;
    slice cs = config_param(config::stake).begin_parse();
    return (cs~load_coins(), cs~load_coins(), cs~load_coins(), cs~load_uint(32));
}

(int, int) get_vset_times(int i) impure {
    ;; validators_ext#12 utime_since:uint32 utime_until:uint32
    ;;   total:(## 16) main:(## 16) { main <= total } { main >= 1 }
    ;;   total_weight:uint64 list:(HashmapE 16 ValidatorDescr) = ValidatorSet;
    slice cs = config_param(i).begin_parse();
    throw_unless(err::unexpected_validator_set_format, cs~load_uint(8) == 0x12);
    return (cs~load_uint(32), cs~load_uint(32));
}

cell create_state_init(cell code, cell data) {
    ;; _ split_depth:(Maybe (## 5)) special:(Maybe TickTock)
    ;;   code:(Maybe ^Cell) data:(Maybe ^Cell)
    ;;   library:(HashmapE 256 SimpleLib) = StateInit;
    return begin_cell()
        .store_uint(6, 5) ;; 00110
        .store_ref(code)
        .store_ref(data)
        .end_cell();
}

builder create_address(int wc, int addr) {
    ;; addr_std$10 anycast:(Maybe Anycast)
    ;;   workchain_id:int8 address:bits256  = MsgAddressInt;
    return begin_cell()
        .store_uint(4, 3) ;; 100
        .store_uint(wc, 8)
        .store_uint(addr, 256);
}

builder to_builder(slice s) {
    return begin_cell().store_slice(s);
}

cell create_wallet_data(builder owner, slice root, cell wallet_code) {
    return begin_cell()
        .store_builder(owner)
        .store_slice(root)
        .store_coins(0) ;; unstaked_tokens
        .store_uint(0, 1) ;; tokens_dict
        .store_ref(wallet_code)
        .end_cell();
}

cell create_pool_data(slice root, builder validator, int round_since) {
    return begin_cell()
        .store_uint(0, 2) ;; addr_none for elector
        .store_slice(root)
        .store_builder(validator)
        .store_uint(round_since, 32)
        .end_cell();
}

(builder, cell, int) create_wallet_address(builder owner, slice root, cell wallet_code) {
    cell wallet_data = create_wallet_data(owner, root, wallet_code);
    cell state_init = create_state_init(wallet_code, wallet_data);
    int addr = state_init.cell_hash();
    builder wallet = create_address(chain::base, addr);
    return (wallet, state_init, addr);
}

(builder, cell, int) create_pool_address(slice root, builder validator, int round_since, cell pool_code) {
    cell pool_data = create_pool_data(root, validator, round_since);
    cell state_init = create_state_init(pool_code, pool_data);
    int addr = state_init.cell_hash();
    builder pool = create_address(chain::main, addr);
    return (pool, state_init, addr);
}

(cell, cell) extract_send_amounts(cell tokens_dict, int send_amount) {
    cell send_amounts = new_dict();
    int stake_time = 1 << 32;
    do {
        ( stake_time, slice v, int f? ) = tokens_dict.udict_get_prev?(32, stake_time);
        if (f?) {
            int stake_amount = v~load_coins();
            v.end_parse();
            if (send_amount >= stake_amount) {
                send_amount -= stake_amount;
                send_amounts~udict_set_builder(32, stake_time, begin_cell().store_coins(stake_amount));
            } else {
                send_amounts~udict_set_builder(32, stake_time, begin_cell().store_coins(send_amount));
                stake_amount -= send_amount;
                send_amount = 0;
                tokens_dict~udict_set_builder(32, stake_time, begin_cell().store_coins(stake_amount));
            }
        }
        f? &= send_amount > 0;
    } until (~ f?);
    throw_unless(err::insufficient_funds, send_amount == 0);
    return ( send_amounts, tokens_dict );
}

() check_new_stake_msg(slice cs) impure {
    cs~skip_bits(256 + 32 + 32 + 256);
    cs~load_ref().begin_parse().skip_bits(512);
    cs.end_parse();
}

;; https://github.com/ton-blockchain/ton/blob/ae5c0720143e231c32c3d2034cfe4e533a16d969/crypto/block/block.tlb#L721
int max_recommended_punishment_for_validator_misbehaviour(int stake) inline_ref {
    ;; misbehaviour_punishment_config_v1#01
    ;;   default_flat_fine:Grams default_proportional_fine:uint32
    ;;   severity_flat_mult:uint16 severity_proportional_mult:uint16
    ;;   unpunishable_interval:uint16
    ;;   long_interval:uint16 long_flat_mult:uint16 long_proportional_mult:uint16
    ;;   medium_interval:uint16 medium_flat_mult:uint16 medium_proportional_mult:uint16
    ;;    = MisbehaviourPunishmentConfig;
    ;; _ MisbehaviourPunishmentConfig = ConfigParam 40;

    cell cp = config_param(config::misbehaviour_punishment);
    if (cell_null?(cp)) {
        ;; 101 TON - https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/lite-client/lite-client.cpp#L3678
        return 101000000000;
    }

    slice cs = cp.begin_parse();

    ( int prefix
    , int default_flat_fine, int default_proportional_fine
    , int severity_flat_mult, int severity_proportional_mult
    , int unpunishable_interval
    , int long_interval, int long_flat_mult, int long_proportional_mult
    ) = ( cs~load_uint(8)
        , cs~load_coins(), cs~load_uint(32)
        , cs~load_uint(16), cs~load_uint(16)
        , cs~load_uint(16)
        , cs~load_uint(16), cs~load_uint(16), cs~load_uint(16)
        );

    ;; https://github.com/ton-blockchain/ton/blob/master/lite-client/lite-client.cpp#L3721
    int fine = default_flat_fine;
    int fine_part = default_proportional_fine;

    fine *= severity_flat_mult;
    fine >>= 8;
    fine_part *= severity_proportional_mult;
    fine_part >>= 8;

    fine *= long_flat_mult;
    fine >>= 8;
    fine_part *= long_proportional_mult;
    fine_part >>= 8;

    ;; https://github.com/ton-blockchain/ton/blob/b38d227a469666d83ac535ad2eea80cb49d911b8/crypto/smartcont/elector-code.fc#L529
    return min(stake, fine + muldiv(stake, fine_part, 1 << 32));
}
