#include "imports/utils.fc";

global int total_coins;
global int total_tokens;
global int total_staking;
global int total_unstaking;
global int total_borrowers_stake;
global slice parent;
global cell participations;
global int rounds_imbalance;
global int stopped?;
global int instant_mint?;
global cell loan_codes;
global cell extension;

global int last_staked;
global int last_recovered;
global slice halter;
global slice governor;
global cell proposed_governor;
global int governance_fee;
global cell collection_codes;
global cell bill_codes;
global cell old_parents;

() save_data() impure inline_ref {
    begin_cell()
        .store_coins(total_coins)
        .store_coins(total_tokens)
        .store_coins(total_staking)
        .store_coins(total_unstaking)
        .store_coins(total_borrowers_stake)
        .store_slice(parent)
        .store_dict(participations)
        .store_uint(rounds_imbalance, 8)
        .store_int(stopped?, 1)
        .store_int(instant_mint?, 1)
        .store_ref(loan_codes)
        .store_ref(extension)
        .end_cell()
        .set_data();
}

() load_data() impure inline_ref {
    slice ds = get_data().begin_parse();
    total_coins = ds~load_coins();
    total_tokens = ds~load_coins();
    total_staking = ds~load_coins();
    total_unstaking = ds~load_coins();
    total_borrowers_stake = ds~load_coins();
    parent = ds~load_msg_addr();
    participations = ds~load_dict();
    rounds_imbalance = ds~load_uint(8);
    stopped? = ds~load_int(1);
    instant_mint? = ds~load_int(1);
    loan_codes = ds~load_ref();
    extension = ds~load_ref();
    ds.end_parse();
}

() pack_extension() impure inline_ref {
    extension = begin_cell()
        .store_coins(last_staked)
        .store_coins(last_recovered)
        .store_slice(halter)
        .store_slice(governor)
        .store_maybe_ref(proposed_governor)
        .store_uint(governance_fee, 16)
        .store_ref(collection_codes)
        .store_ref(bill_codes)
        .store_dict(old_parents)
        .end_cell();
}

() unpack_extension() impure inline_ref {
    slice s = extension.begin_parse();
    last_staked = s~load_coins();
    last_recovered = s~load_coins();
    halter = s~load_msg_addr();
    governor = s~load_msg_addr();
    proposed_governor = s~load_maybe_ref();
    governance_fee = s~load_uint(16);
    collection_codes = s~load_ref();
    bill_codes = s~load_ref();
    old_parents = s~load_dict();
    s.end_parse();
}

builder pack_participation
    ( int state
    , int size
    , cell sorted
    , cell requests
    , cell rejected
    , cell accepted
    , cell accrued
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) inline_ref {
    return begin_cell()
        .store_uint(state, 4)
        .store_uint(size, 16)
        .store_dict(sorted)
        .store_dict(requests)
        .store_dict(rejected)
        .store_dict(accepted)
        .store_dict(accrued)
        .store_dict(staked)
        .store_dict(recovering)
        .store_coins(total_staked)
        .store_coins(total_recovered)
        .store_uint(current_vset_hash, 256)
        .store_uint(stake_held_for, 32)
        .store_uint(stake_held_until, 32);
}

var unpack_participation(slice s) inline_ref {
    int state = s~load_uint(4);
    int size = s~load_uint(16);
    cell sorted = s~load_dict();
    cell requests = s~load_dict();
    cell rejected = s~load_dict();
    cell accepted = s~load_dict();
    cell accrued = s~load_dict();
    cell staked = s~load_dict();
    cell recovering = s~load_dict();
    int total_staked = s~load_coins();
    int total_recovered = s~load_coins();
    int current_vset_hash = s~load_uint(256);
    int stake_held_for = s~load_uint(32);
    int stake_held_until = s~load_uint(32);
    s.end_parse();
    return
        ( state
        , size
        , sorted
        , requests
        , rejected
        , accepted
        , accrued
        , staked
        , recovering
        , total_staked
        , total_recovered
        , current_vset_hash
        , stake_held_for
        , stake_held_until
        );
}

builder pack_request
    ( int min_payment
    , int borrower_reward_share
    , int loan_amount
    , int accrue_amount
    , int stake_amount
    , cell new_stake_msg
    ) inline_ref {
    return begin_cell()
        .store_coins(min_payment)
        .store_uint(borrower_reward_share, 8)
        .store_coins(loan_amount)
        .store_coins(accrue_amount)
        .store_coins(stake_amount)
        .store_ref(new_stake_msg);
}

(int, int, int, int, int, cell) unpack_request(slice s) inline_ref {
    int min_payment = s~load_coins();
    int borrower_reward_share = s~load_uint(8);
    int loan_amount = s~load_coins();
    int accrue_amount = s~load_coins();
    int stake_amount = s~load_coins();
    cell new_stake_msg = s~load_ref();
    s.end_parse();
    return ( min_payment, borrower_reward_share, loan_amount, accrue_amount, stake_amount, new_stake_msg );
}

cell find_code(cell dict, int round_since) inline {
    ( _, slice code_slice, _ ) = dict.udict_get_preveq?(32, round_since);
    cell code = code_slice~load_ref();
    code_slice.end_parse();
    return code;
}

() deposit_coins(slice src, slice s) impure inline_ref {
    int query_id = s~load_uint(64);
    slice owner = s~load_msg_addr();
    int coins = s~load_coins();
    int ownership_assigned_amount = s~load_coins();
    s~load_msg_addr(); ;; only used to mark the referrer of this deposit on-chain
    s.end_parse();

    if owner.addr_none?() {
        owner = src;
    }

    ( int total_fee, int proxy_save_coins_fee ) = deposit_coins_fee(ownership_assigned_amount);
    int incoming_ton = get_incoming_value().pair_first();
    int max_coins = incoming_ton - total_fee;
    ifnot coins {
        coins = max_coins;
    }
    int enough_fee? = (max_coins >= coins) & (max_coins > 0);
    ( int owner_wc, _ ) = parse_std_addr(owner);

    throw_unless(err::only_basechain_allowed, owner_wc == chain::base);
    throw_unless(err::insufficient_fee, enough_fee?);
    throw_if(err::stopped, stopped?);

    int round_since = 0;
    ifnot instant_mint? {
        int k = 1 << 32;
        do {
            ( k, slice v, int f? ) = participations.udict_get_prev?(32, k);
            if f? {
                int state = v~load_uint(4);
                if (state > participation::open) & (state < participation::burning) {
                    ;; stake after rewards for this round has been distributed
                    round_since = k;
                    f? = false;
                }
            }
        } until ~ f?;
    }

    raw_reserve(coins, reserve::add_original_balance);

    ifnot round_since {
        int tokens = coins;
        if total_coins {
            tokens = muldiv(coins, total_tokens, total_coins);
        }

        total_coins += coins;
        total_tokens += tokens;

        builder minted = begin_cell()
            .store_uint(op::proxy_tokens_minted, 32)
            .store_uint(query_id, 64)
            .store_coins(tokens)
            .store_coins(coins)
            .store_slice(owner)
            .store_uint(round_since, 32);
        send_msg(false, parent.to_builder(), null(), minted, 0, send::unreserved_balance);
    } else {
        total_staking += coins;

        unpack_extension();

        cell collection_code = collection_codes.find_code(round_since);
        cell bill_code = bill_codes.find_code(round_since);

        ( builder collection
        , builder state_init
        , _
        ) = create_collection_address(my_address(), round_since, bill_code, collection_code);

        builder save = begin_cell()
            .store_uint(op::proxy_save_coins, 32)
            .store_uint(query_id, 64)
            .store_coins(coins)
            .store_slice(owner)
            .store_uint(round_since, 32);
        send_msg(false, parent.to_builder(), null(), save, proxy_save_coins_fee, send::pay_gas_separately);

        builder mint = begin_cell()
            .store_uint(op::mint_bill, 32)
            .store_uint(query_id, 64)
            .store_coins(coins)
            .store_int(false, 1)
            .store_slice(owner)
            .store_slice(parent)
            .store_coins(ownership_assigned_amount);
        send_msg(false, collection, state_init, mint, 0, send::unreserved_balance);
    }
}

() reserve_tokens(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    slice owner = s~load_msg_addr();
    int mode = s~load_uint(4);
    int ownership_assigned_amount = s~load_coins();
    s.end_parse();

    int coins = tokens;
    if tokens == total_tokens {
        coins = total_coins; ;; send all coins to last staker
    } elseif total_tokens {
        coins = muldiv(tokens, total_coins, total_tokens);
    }

    int incoming_ton = get_incoming_value().pair_first();
    int ton_balance = get_balance().pair_first();
    int ton_balance_before_msg = ton_balance - incoming_ton;
    int available_ton = ton_balance_before_msg - fee::treasury_storage - total_borrowers_stake;

    int round_since = 0;
    int k = -1;
    do {
        ( k, slice v, int f? ) = participations.udict_get_next?(32, k);
        if f? {
            int state = v~load_uint(4);
            if (state > participation::open) & (state < participation::burning) {
                ;; burn tokens after this round has been finalized
                round_since = k;
                f? = false;
            }
        }
    } until ~ f?;

    ;; Maybe old wallets are trying to unstake. Those wallets must first upgrade. Rollback the unstake request.
    int rollback? = ~ equal_slice_bits(src, parent);
    ;; No funds locked in the next round. This should not happen. At least rollback the unstake request.
    rollback? |= (round_since == 0) & (available_ton < coins);
    ;; User requested instant operation, but there is not enough funds. Rollback the unstake request.
    rollback? |= (mode == unstake::instant) & (available_ton < coins);

    if rollback? {
        builder rollback = begin_cell()
            .store_uint(op::proxy_rollback_unstake, 32)
            .store_uint(query_id, 64)
            .store_coins(tokens)
            .store_slice(owner);
        send_msg(false, src.to_builder(), null(), rollback, 0, send::remaining_value);

        throw(0);
    }

    if (available_ton >= coins) & ((mode <= unstake::instant) | (round_since == 0)) {
        total_coins -= coins;
        total_tokens -= tokens;

        raw_reserve(coins, reserve::negate + reserve::add_original_balance);

        builder burned = begin_cell()
            .store_uint(op::proxy_tokens_burned, 32)
            .store_uint(query_id, 64)
            .store_coins(tokens)
            .store_coins(coins)
            .store_slice(owner);
        send_msg(false, parent.to_builder(), null(), burned, 0, send::unreserved_balance);
    } else {
        total_unstaking += tokens;

        unpack_extension();

        cell collection_code = collection_codes.find_code(round_since);
        cell bill_code = bill_codes.find_code(round_since);

        ( builder collection
        , builder state_init
        , _
        ) = create_collection_address(my_address(), round_since, bill_code, collection_code);

        builder mint = begin_cell()
            .store_uint(op::mint_bill, 32)
            .store_uint(query_id, 64)
            .store_coins(tokens)
            .store_int(true, 1)
            .store_slice(owner)
            .store_slice(parent)
            .store_coins(ownership_assigned_amount);
        send_msg(false, collection, state_init, mint, 0, send::remaining_value);
    }
}

() mint_tokens(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    int coins = s~load_coins();
    slice owner = s~load_msg_addr();
    slice fixed_parent = s~load_msg_addr();
    int round_since = s~load_uint(32);
    s.end_parse();

    cell collection_code = collection_codes.find_code(round_since);
    cell bill_code = bill_codes.find_code(round_since);

    ( _, _, int collection_addr ) = create_collection_address(my_address(), round_since, bill_code, collection_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::base) & (src_addr == collection_addr));

    int tokens = coins;
    if total_coins {
        tokens = muldiv(coins, total_tokens, total_coins);
    }

    total_staking -= coins;
    total_coins += coins;
    total_tokens += tokens;

    builder minted = begin_cell()
        .store_uint(op::proxy_tokens_minted, 32)
        .store_uint(query_id, 64)
        .store_coins(tokens)
        .store_coins(coins)
        .store_slice(owner)
        .store_uint(round_since, 32);
    send_msg(false, fixed_parent.to_builder(), null(), minted, 0, send::remaining_value);
}

() burn_tokens(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    slice owner = s~load_msg_addr();
    slice fixed_parent = s~load_msg_addr();
    int round_since = s~load_uint(32);
    s.end_parse();

    cell collection_code = collection_codes.find_code(round_since);
    cell bill_code = bill_codes.find_code(round_since);

    ( _, _, int collection_addr ) = create_collection_address(my_address(), round_since, bill_code, collection_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::base) & (src_addr == collection_addr));

    int coins = tokens;
    if tokens == total_tokens {
        coins = total_coins; ;; send all coins to last staker
    } elseif total_tokens {
        coins = muldiv(tokens, total_coins, total_tokens);
    }

    int incoming_ton = get_incoming_value().pair_first();
    int ton_balance = get_balance().pair_first();
    int ton_balance_before_msg = ton_balance - incoming_ton;
    int available_ton = ton_balance_before_msg - fee::treasury_storage - total_borrowers_stake;

    if available_ton < coins {
        ;; Insufficient funds to burn tokens now, try to create another bill for next round.
        int next_round_since = 0;
        int k = round_since;
        do {
            ( k, slice v, int f? ) = participations.udict_get_next?(32, k);
            if f? {
                int state = v~load_uint(4);
                if (state > participation::open) & (state < participation::burning) {
                    ;; Burn tokens after this round has been finalized.
                    next_round_since = k;
                    f? = false;
                }
            }
        } until ~ f?;

        ifnot next_round_since {
            ;; No more rounds to postpone to. This should not happen. At least log it.
            log_failed_burning_tokens(round_since, total_coins, total_tokens, coins, tokens, owner);
        } else {
            ( builder collection
            , builder state_init
            , _
            ) = create_collection_address(my_address(), next_round_since, bill_code, collection_code);

            builder mint = begin_cell()
                .store_uint(op::mint_bill, 32)
                .store_uint(query_id, 64)
                .store_coins(tokens)
                .store_int(true, 1)
                .store_slice(owner)
                .store_slice(fixed_parent)
                .store_coins(0);
            send_msg(false, collection, state_init, mint, 0, send::remaining_value);
        }

        throw(0);
    }

    total_coins -= coins;
    total_tokens -= tokens;
    total_unstaking -= tokens;

    raw_reserve(coins, reserve::negate + reserve::add_original_balance);

    builder burned = begin_cell()
        .store_uint(op::proxy_tokens_burned, 32)
        .store_uint(query_id, 64)
        .store_coins(tokens)
        .store_coins(coins)
        .store_slice(owner);
    send_msg(false, fixed_parent.to_builder(), null(), burned, 0, send::unreserved_balance);
}

() send_unstake_all(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    s.end_parse();

    int fee = unstake_all_fee();
    int incoming_ton = get_incoming_value().pair_first();
    ( int src_wc, _ ) = parse_std_addr(src);

    throw_unless(err::only_basechain_allowed, src_wc == chain::base);
    throw_unless(err::insufficient_fee, incoming_ton >= fee);

    builder unstake = begin_cell()
        .store_uint(op::proxy_unstake_all, 32)
        .store_uint(query_id, 64)
        .store_slice(src);
    send_msg(false, parent.to_builder(), null(), unstake, 0, send::remaining_value);

    throw(0);
}

() provide_current_quote(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    cell custom_payload = s~load_maybe_ref();
    s.end_parse();

    builder quote = begin_cell()
        .store_uint(op::take_current_quote, 32)
        .store_uint(query_id, 64)
        .store_uint(total_coins, 128)
        .store_uint(total_tokens, 128)
        .store_maybe_ref(custom_payload);
    send_msg(false, src.to_builder(), null(), quote, 0, send::remaining_value);

    throw(0);
}

(int, int, int, int, int, int) get_times() inline_ref method_id {
    ( int current_round_since, int next_round_since ) = get_vset_times(config::current_validators);
    ( int validators_elected_for
    , _
    , int elections_end_before
    , int stake_held_for
    ) = get_election_config();
    int participate_since = next_round_since - elections_end_before - 900; ;; at least, 15 minute before end of election
    int participate_until = participate_since + 600; ;; at most, 5 minute before end of election
    int next_round_until = next_round_since + validators_elected_for;
    return
        ( current_round_since
        , participate_since
        , participate_until
        , next_round_since
        , next_round_until
        , stake_held_for
        );
}

() request_loan(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    int loan_amount = s~load_coins();
    int min_payment = s~load_coins();
    int borrower_reward_share = s~load_uint(8);
    cell new_stake_msg = s~load_ref();
    s.end_parse();
    check_new_stake_msg(new_stake_msg.begin_parse());

    ( int borrower_wc, int borrower_addr ) = parse_std_addr(src);
    ( int min_stake, _, _, _ ) = get_stake_config();
    ( _, int participate_since, _, int next_round_since, _, _ ) = get_times();
    int state = participation::open;
    int size = 0;
    cell sorted = new_dict();
    cell requests = new_dict();
    int old_stake_amount = 0;
    ( slice ps, int f? ) = participations.udict_get?(32, next_round_since);
    if f? {
        ( state, size, sorted, requests, _, _, _, _, _, _, _, _, _, _ ) = unpack_participation(ps);
        ( slice old_request, int e? ) = requests~udict_delete_get?(256, borrower_addr);
        if e? {
            size -= 1;
            ;; clean up old request
            ( int old_min_payment
            , int old_borrower_reward_share
            , int old_loan_amount
            , _
            , old_stake_amount
            , _
            ) = unpack_request(old_request);

            int old_sort_key = request_sort_key(old_min_payment, old_borrower_reward_share, old_loan_amount);
            ( cell old_bucket, _ ) = sorted.udict_get_ref?(112, old_sort_key);
            old_bucket~udict_delete?(256, borrower_addr);
            if old_bucket.null?() {
                sorted~udict_delete?(112, old_sort_key);
            } else {
                sorted~udict_set_ref(112, old_sort_key, old_bucket);
            }
        }
    } else {
        ;; do not create a new participation if there are already 7 participation
        int participations_count = 0;
        int k = -1;
        do {
            ( k, _, int more? ) = participations.udict_get_next?(32, k);
            if more? {
                participations_count += 1;
            }
        } until ~ more?;
        throw_unless(err::not_accepting_loan_requests, participations_count <= 7);
    }
    ( int total_fee, _, _ ) = request_loan_fee();
    int incoming_ton = get_incoming_value().pair_first();
    int stake_amount = incoming_ton - total_fee + old_stake_amount;
    total_borrowers_stake += stake_amount - old_stake_amount;
    int max_punishment = max_recommended_punishment_for_validator_misbehaviour(loan_amount + stake_amount);

    throw_unless(err::access_denied, borrower_wc == chain::base);
    throw_unless(err::not_accepting_loan_requests, state == participation::open);
    throw_unless(err::not_accepting_loan_requests, round_since == next_round_since);
    throw_unless(err::not_accepting_loan_requests, now() < participate_since);
    throw_unless(err::insufficient_funds, stake_amount + loan_amount >= min_stake + fee::new_stake_confirmation);
    throw_unless(err::insufficient_funds, stake_amount >= min_payment + max_punishment);
    throw_if(err::stopped, stopped?);

    builder request = pack_request(min_payment, borrower_reward_share, loan_amount, 0, stake_amount, new_stake_msg);
    requests~udict_set_builder(256, borrower_addr, request);
    size += 1;

    int sort_key = request_sort_key(min_payment, borrower_reward_share, loan_amount);
    ( cell bucket, _ ) = sorted.udict_get_ref?(112, sort_key);
    bucket~udict_set_builder(256, borrower_addr, begin_cell());
    sorted~udict_set_ref(112, sort_key, bucket);

    ( int max_validators, _, _ ) = get_validators_config();
    max_validators = min(max_validators, 100); ;; before increasing 100, check gas usage using MaxGas
    if size > max_validators {
        ( int last_sort_key, slice v, _ ) = sorted~udict_delete_get_min?(112);
        cell last_bucket = v~load_ref();
        ( int last_borrower_addr, _, _ ) = last_bucket~udict_delete_get_max?(256);
        ( slice last_request, _ ) = requests~udict_delete_get?(256, last_borrower_addr);
        size -= 1;
        ifnot last_bucket.null?() {
            sorted~udict_set_ref(112, last_sort_key, last_bucket);
        }
        builder last_borrower = create_address(chain::base, last_borrower_addr);
        ( _, _, _, _, int last_stake_amount, _ ) = unpack_request(last_request);
        total_borrowers_stake -= last_stake_amount;

        builder rejected = begin_cell()
            .store_uint(op::request_rejected, 32)
            .store_uint(query_id, 64);
        send_msg(false, last_borrower, null(), rejected, last_stake_amount, send::pay_gas_separately);
    }

    builder pb = pack_participation(
        state, size, sorted, requests, new_dict(), new_dict(), new_dict(), new_dict(), new_dict(),
        0, 0, 0, 0, 0
    );
    participations~udict_set_builder(32, next_round_since, pb);
}

() distribute(int query_id, int round_since) impure inline_ref {
    ifnot query_id {
        ;; force reply from elector when staking
        query_id = cur_lt();
    }
    ( slice ps, _ ) = participations.udict_get?(32, round_since);
    ( int state, int size, cell sorted, cell requests, _, _, _, _, _, _, _, _, _, _ ) = unpack_participation(ps);
    ( _, _, int participate_until, _, int next_round_until, int stake_held_for ) = get_times();

    int current_vset_hash = config_param(config::current_validators).cell_hash();
    int stake_held_until = next_round_until + stake_held_for + 60;

    int reserved_amount = total_unstaking;
    if total_tokens {
        reserved_amount = muldiv(total_unstaking, total_coins, total_tokens);
    }
    ( int total_fee, _, _ ) = request_loan_fee();
    int ton_balance = get_balance().pair_first();
    int available_now =
        max(0, ton_balance - fee::treasury_storage - total_borrowers_stake - size * total_fee - reserved_amount);

    int last_total_staked = 0;
    ( _, ps, int f? ) = participations.udict_get_prev?(32, round_since);
    if f? {
        ( _, _, _, _, _, _, _, _, _, last_total_staked, _, _, _, _ ) = unpack_participation(ps);
    }
    int available_max = muldiv(available_now + last_total_staked, rounds_imbalance + 1 + 256, 512);
    int available = min(available_now, available_max);
    int amount = max(size * total_fee, available);

    builder myself = my_address().to_builder();
    int elected? = ~ config_param(config::next_validators).null?();
    int too_late? = now() >= min(participate_until, round_since);
    if elected? | too_late? {
        ;; reject all requests if already elected or there is not enough time for safe participation
        builder pb = pack_participation(
            state, 0, new_dict(), new_dict(), requests, new_dict(), new_dict(), new_dict(), new_dict(),
            0, 0, current_vset_hash, stake_held_for, stake_held_until
        );
        participations~udict_set_builder(32, round_since, pb);

        builder process = begin_cell()
            .store_uint(op::process_loan_requests, 32)
            .store_uint(query_id, 64)
            .store_uint(round_since, 32);
        send_msg(false, myself, null(), process, amount, send::pay_gas_separately + send::ignore_errors);
    } else {
        ;; use total_staked field as a temp var for storing available amount
        builder pb = pack_participation(
            state, size, sorted, requests, new_dict(), new_dict(), new_dict(), new_dict(), new_dict(),
            available, 0, current_vset_hash, stake_held_for, stake_held_until
        );
        participations~udict_set_builder(32, round_since, pb);

        builder decide = begin_cell()
            .store_uint(op::decide_loan_requests, 32)
            .store_uint(query_id, 64)
            .store_uint(round_since, 32);
        send_msg(false, myself, null(), decide, amount, send::pay_gas_separately + send::ignore_errors);
    }
}

() participate_in_election(slice s) impure inline_ref {
    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice ps, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , int size
    , cell sorted
    , cell requests
    , cell rejected
    , cell accepted
    , cell accrued
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(ps);
    ( _, int participate_since, _, _, _, _ ) = get_times();

    throw_unless(err::unable_to_participate, state == participation::open);
    throw_unless(err::too_soon_to_participate, now() >= min(participate_since, round_since));

    accept_message();

    state = participation::distributing;

    builder pb = pack_participation(
        state, size, sorted, requests, rejected, accepted, accrued, staked, recovering,
        total_staked, total_recovered, current_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pb);

    save_data();
    commit();

    distribute(query_id, round_since);
}

() decide_loan_requests(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice ps, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , int size
    , cell sorted
    , cell requests
    , cell rejected
    , cell accepted
    , cell accrued
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(ps);

    throw_unless(err::access_denied, equal_slice_bits(src, my_address()));

    int available = total_staked; ;; use the total_staked field as a temp var for available amount
    int allocated = total_recovered; ;; use the total_recovered field as a temp var for allocated amount

    int soft_gas_limit = muldiv(gas_limit, 8, 10);
    int remain = 255 - 1; ;; keep the last one for continue message

    while remain & (gas_consumed() < soft_gas_limit) & ~ sorted.dict_empty?() {
        ;; sorted is in ascending order, read from the end
        ( int k, slice v, _ ) = sorted.udict_get_max?(112);
        cell bucket = v~load_ref();
        while remain & (gas_consumed() < soft_gas_limit) & ~ bucket.dict_empty?() {
            remain -= 1;
            ( int borrower_addr, _, _ ) = bucket~udict_delete_get_min?(256);
            if bucket.dict_empty?() {
                sorted~udict_delete?(112, k);
            } else {
                sorted~udict_set_ref(112, k, bucket);
            }
            ( slice request, _ ) = requests~udict_delete_get?(256, borrower_addr);
            ( _, _, int loan_amount, _, _, _ ) = unpack_request(request);
            if available >= loan_amount {
                available -= loan_amount;
                allocated += loan_amount;
                accepted~udict_set(256, borrower_addr, request);
            } else {
                rejected~udict_set(256, borrower_addr, request);
            }
        }
    }

    ;; distribute remaining coins between accepted requests, when they have enough stake
    while remain & (gas_consumed() < soft_gas_limit) & ~ accepted.dict_empty?() {
        remain -= 1;
        ( int borrower_addr, slice request, _ ) = accepted~udict_delete_get_min?(256);
        ( int min_payment
        , int borrower_reward_share
        , int loan_amount
        , _
        , int stake_amount
        , cell new_stake_msg
        ) = unpack_request(request);
        int accrue_amount = muldiv(available, loan_amount, allocated);
        int total_loan_amount = loan_amount + accrue_amount + stake_amount;
        int max_punishment = max_recommended_punishment_for_validator_misbehaviour(total_loan_amount);
        if stake_amount >= min_payment + max_punishment {
            builder accrued_request = pack_request(
                min_payment, borrower_reward_share, loan_amount, accrue_amount, stake_amount, new_stake_msg
            );
            accrued~udict_set_builder(256, borrower_addr, accrued_request);
        } else {
            accrued~udict_set(256, borrower_addr, request);
        }
    }

    if sorted.dict_empty?() & accepted.dict_empty?() {
        total_staked = 0;
        total_recovered = 0;

        builder process = begin_cell()
            .store_uint(op::process_loan_requests, 32)
            .store_uint(query_id, 64)
            .store_uint(round_since, 32);
        send_msg(false, my_address().to_builder(), null(), process, 0, send::remaining_value);
    } else {
        total_staked = available;
        total_recovered = allocated;

        builder decide = begin_cell()
            .store_uint(op::decide_loan_requests, 32)
            .store_uint(query_id, 64)
            .store_uint(round_since, 32);
        send_msg(false, my_address().to_builder(), null(), decide, 0, send::remaining_value);
    }

    builder pb = pack_participation(
        state, size, sorted, requests, rejected, accepted, accrued, staked, recovering,
        total_staked, total_recovered, current_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pb);
}

() process_loan_requests(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice ps, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , int size
    , cell sorted
    , cell requests
    , cell rejected
    , cell accepted
    , cell accrued
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(ps);

    ( int total_fee, int proxy_new_stake_fee, _ ) = request_loan_fee();

    throw_unless(err::access_denied, equal_slice_bits(src, my_address()));

    cell loan_code = loan_codes.find_code(round_since);

    int incoming_ton = get_incoming_value().pair_first();

    int soft_gas_limit = muldiv(gas_limit, 8, 10);
    int remain = 255 - 1; ;; keep the last one for continue message

    ;; send new stake message for each accrued request
    while remain & (gas_consumed() < soft_gas_limit) & ~ accrued.dict_empty?() {
        remain -= 1;
        ( int borrower_addr, slice request, _ ) = accrued~udict_delete_get_min?(256);
        ( int min_payment
        , int borrower_reward_share
        , int loan_amount
        , int accrue_amount
        , int stake_amount
        , cell new_stake_msg
        ) = unpack_request(request);
        builder borrower = create_address(chain::base, borrower_addr);
        ( builder loan, builder state_init, _ ) = create_loan_address(my_address(), borrower, round_since, loan_code);
        int ton_amount = loan_amount + accrue_amount + stake_amount + proxy_new_stake_fee;
        total_staked += loan_amount + accrue_amount;
        staked~udict_set(256, borrower_addr, request);
        total_borrowers_stake -= stake_amount;
        incoming_ton -= ton_amount;

        builder body = begin_cell()
            .store_uint(op::proxy_new_stake, 32)
            .store_uint(query_id, 64)
            .store_ref(new_stake_msg);
        send_msg(true, loan, state_init, body, ton_amount, send::regular);

        log_loan(round_since, min_payment, borrower_reward_share, loan_amount, accrue_amount, stake_amount, borrower);
    }

    ;; send back staked amount of rejected requests
    while remain & (gas_consumed() < soft_gas_limit) & ~ rejected.dict_empty?() {
        remain -= 1;
        size -= 1;
        ( int borrower_addr, slice request, _ ) = rejected~udict_delete_get_min?(256);
        ( _, _, _, _, int stake_amount, _ ) = unpack_request(request);
        builder borrower = create_address(chain::base, borrower_addr);
        total_borrowers_stake -= stake_amount;

        builder rejected = begin_cell()
            .store_uint(op::request_rejected, 32)
            .store_uint(query_id, 64);
        send_msg(false, borrower, null(), rejected, stake_amount, send::pay_gas_separately);
    }

    ifnot rejected.dict_empty?() & accrued.dict_empty?() {
        ;; continue sending messages until done
        builder process = begin_cell()
            .store_uint(op::process_loan_requests, 32)
            .store_uint(query_id, 64)
            .store_uint(round_since, 32);
        send_msg(false, my_address().to_builder(), null(), process, max(incoming_ton, size * total_fee), send::regular);
    } else {
        state = participation::staked;
    }

    if rejected.dict_empty?() & accrued.dict_empty?() & staked.dict_empty?() & recovering.dict_empty?() {
        ;; no more requests, remove empty participation data
        participations~udict_delete?(32, round_since);
    } else {
        builder pb = pack_participation(
            state, size, sorted, requests, rejected, accepted, accrued, staked, recovering,
            total_staked, total_recovered, current_vset_hash, stake_held_for, stake_held_until
        );
        participations~udict_set_builder(32, round_since, pb);
    }
}

() vset_changed(slice s) impure inline_ref {
    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice ps, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , int size
    , cell sorted
    , cell requests
    , cell rejected
    , cell accepted
    , cell accrued
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(ps);
    int new_vset_hash = config_param(config::current_validators).cell_hash();
    ( _, int next_round_since ) = get_vset_times(config::current_validators);

    throw_unless(err::vset_not_changed, new_vset_hash != current_vset_hash);
    throw_unless(err::vset_not_changeable, (state == participation::staked) | (state == participation::validating));

    accept_message();

    if state == participation::staked {
        state = participation::validating;
        stake_held_until = next_round_since + stake_held_for + 60;
    } else {
        state = participation::held;
        stake_held_until = now() + stake_held_for + 60;
    }

    builder pb = pack_participation(
        state, size, sorted, requests, rejected, accepted, accrued, staked, recovering,
        total_staked, total_recovered, new_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pb);

    save_data();
    commit();

    throw(0);
}

() finish_participation(slice s) impure inline_ref {
    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice ps, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , int size
    , cell sorted
    , cell requests
    , cell rejected
    , cell accepted
    , cell accrued
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(ps);

    throw_unless(err::not_ready_to_finish_participation, state == participation::held);
    throw_unless(err::too_soon_to_finish_participation, now() >= stake_held_until);

    accept_message();

    state = participation::recovering;

    builder pb = pack_participation(
        state, size, sorted, requests, rejected, accepted, accrued, staked, recovering,
        total_staked, total_recovered, current_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pb);

    save_data();
    commit();

    builder myself = my_address().to_builder();
    builder continue = begin_cell()
        .store_uint(op::recover_stakes, 32)
        .store_uint(query_id, 64)
        .store_uint(round_since, 32);
    send_msg(false, myself, null(), continue, max_gas_fee(), send::pay_gas_separately + send::ignore_errors);

    throw(0);
}

() recover_stakes(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice ps, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , int size
    , cell sorted
    , cell requests
    , cell rejected
    , cell accepted
    , cell accrued
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(ps);

    ( _, _, int recover_stake_fee ) = request_loan_fee();

    throw_unless(err::access_denied, equal_slice_bits(src, my_address()));

    cell loan_code = loan_codes.find_code(round_since);

    int incoming_ton = get_incoming_value().pair_first();

    int soft_gas_limit = muldiv(gas_limit, 8, 10);
    int remain = 255 - 1; ;; keep the last one for continue message

    ;; send recover stake message from each given loan
    while remain & (gas_consumed() < soft_gas_limit) & ~ staked.dict_empty?() {
        remain -= 1;
        ( int borrower_addr, slice request, _ ) = staked~udict_delete_get_min?(256);
        recovering~udict_set(256, borrower_addr, request);
        builder borrower = create_address(chain::base, borrower_addr);
        ( builder loan, _, _ ) = create_loan_address(my_address(), borrower, round_since, loan_code);

        builder recover = begin_cell()
            .store_uint(op::proxy_recover_stake, 32)
            .store_uint(query_id, 64);
        send_msg(true, loan, null(), recover, recover_stake_fee, send::regular);
    }

    ifnot staked.dict_empty?() {
        ;; continue sending messages until done
        builder continue = begin_cell()
            .store_uint(op::recover_stakes, 32)
            .store_uint(query_id, 64)
            .store_uint(round_since, 32);
        send_msg(false, my_address().to_builder(), null(), continue, incoming_ton, send::pay_gas_separately);
    }

    builder pb = pack_participation(
        state, size, sorted, requests, rejected, accepted, accrued, staked, recovering,
        total_staked, total_recovered, current_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pb);
}

() recover_stake_result(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    int ok? = s~load_int(1);
    slice borrower = s~load_msg_addr();
    int round_since = s~load_uint(32);
    s.end_parse();

    cell loan_code = loan_codes.find_code(round_since);

    ( _, _, int loan_addr ) = create_loan_address(my_address(), borrower.to_builder(), round_since, loan_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::main) & (src_addr == loan_addr));

    int reserve_amount = 0;
    int stake_amount = 0;
    ( _, int borrower_addr ) = parse_std_addr(borrower);
    ( slice ps, int f? ) = participations.udict_get?(32, round_since);
    if f? {
        ( int state
        , int size
        , cell sorted
        , cell requests
        , cell rejected
        , cell accepted
        , cell accrued
        , cell staked
        , cell recovering
        , int total_staked
        , int total_recovered
        , int current_vset_hash
        , int stake_held_for
        , int stake_held_until
        ) = unpack_participation(ps);

        ( slice request, int e? ) = recovering~udict_delete_get?(256, borrower_addr);
        ifnot e? {
            ;; for the case that the elector rejects new stake instantly
            ( request, e? ) = staked~udict_delete_get?(256, borrower_addr);
        }
        if e? {
            size -= 1;
            ( int min_payment
            , int borrower_reward_share
            , int loan_amount
            , int accrue_amount
            , stake_amount
            , _
            ) = unpack_request(request);

            int fee = 0;
            int new_coins = 0;
            int incoming_ton = get_incoming_value().pair_first();
            ( _, _, int recover_stake_fee ) = request_loan_fee();
            int reward = incoming_ton - loan_amount - accrue_amount - stake_amount - recover_stake_fee;
            if reward >= 0 {
                int treasury_reward_share = 255 - borrower_reward_share;
                int treasury_reward = max(min_payment, muldiv(reward, treasury_reward_share, 255));
                int borrower_reward = reward - treasury_reward;
                stake_amount += borrower_reward;
                fee = muldiv(treasury_reward, governance_fee, 65535);
                new_coins = treasury_reward - fee;
                total_coins += new_coins;
                reserve_amount = loan_amount + accrue_amount + new_coins;
                total_recovered += reserve_amount;
            } else {
                ;; when reward is negative, punish the borrower first
                int compensation = min(stake_amount, - reward);
                stake_amount -= compensation;
                ;; then try to take at most min_payment
                int treasury_reward = min(stake_amount, min_payment);
                stake_amount -= treasury_reward;
                fee = muldiv(treasury_reward, governance_fee, 65535);
                new_coins = treasury_reward - fee;
                total_coins += new_coins;
                reserve_amount = incoming_ton - stake_amount - fee;
                total_recovered += reserve_amount;
            }

            log_repayment(
                round_since, incoming_ton, loan_amount, accrue_amount, new_coins, fee, stake_amount, borrower
            );

            if rejected.dict_empty?() & accrued.dict_empty?() & staked.dict_empty?() & recovering.dict_empty?() {
                last_staked = total_staked;
                last_recovered = total_recovered;
                state = participation::burning;

                cell collection_code = collection_codes.find_code(round_since);
                cell bill_code = bill_codes.find_code(round_since);

                ( builder collection
                , builder state_init
                , _
                ) = create_collection_address(my_address(), round_since, bill_code, collection_code);

                builder burn = begin_cell()
                    .store_uint(op::burn_all, 32)
                    .store_uint(query_id, 64)
                    .store_uint(0, 64);
                send_msg(false, collection, state_init, burn, burn_all_fee(), send::regular);
            }

            builder pb = pack_participation(
                state, size, sorted, requests, rejected, accepted, accrued, staked, recovering,
                total_staked, total_recovered, current_vset_hash, stake_held_for, stake_held_until
            );
            participations~udict_set_builder(32, round_since, pb);
        }
    }

    raw_reserve(reserve_amount, reserve::add_original_balance + reserve::at_most);

    if stake_amount > 0 {
        builder result = begin_cell()
            .store_uint(op::loan_result, 32)
            .store_uint(query_id, 64);
        send_msg(false, borrower.to_builder(), null(), result, stake_amount, send::ignore_errors);
    }

    builder profit = begin_cell()
        .store_uint(op::take_profit, 32)
        .store_uint(query_id, 64);
    send_msg(false, governor.to_builder(), null(), profit, 0, send::unreserved_balance + send::ignore_errors);

    pack_extension();
}

() last_bill_burned(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    cell collection_code = collection_codes.find_code(round_since);
    cell bill_code = bill_codes.find_code(round_since);

    ( _, _, int collection_addr ) = create_collection_address(my_address(), round_since, bill_code, collection_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::base) & (src_addr == collection_addr));

    ( slice ps, int f? ) = participations~udict_delete_get?(32, round_since);
    ( int state
    , int size
    , cell sorted
    , cell requests
    , cell rejected
    , cell accepted
    , cell accrued
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(ps);

    log_finish(round_since, total_staked, total_recovered, total_coins, total_tokens);
}

() propose_governor(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice new_governor = s~load_msg_addr();
    s.end_parse();

    ( int new_governor_wc, _ ) = parse_std_addr(new_governor);
    new_governor_wc~impure_touch();
    int accept_after = now() + 60 * 60 * 24;
    proposed_governor = begin_cell()
        .store_uint(accept_after, 32)
        .store_slice(new_governor)
        .end_cell();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    pack_extension();
}

() accept_governance(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    s.end_parse();

    slice gs = proposed_governor.begin_parse();
    int accept_after = gs~load_uint(32);
    governor = gs~load_msg_addr();
    gs.end_parse();
    proposed_governor = null();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));
    throw_unless(err::access_denied, now() >= accept_after);

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    pack_extension();
}

() set_halter(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice new_halter = s~load_msg_addr();
    s.end_parse();

    ( int new_halter_wc, _ ) = parse_std_addr(new_halter);
    new_halter_wc~impure_touch();

    throw_unless(err::access_denied, equal_slice_bits(src, governor) | equal_slice_bits(src, halter));

    halter = new_halter;

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    pack_extension();
}

() set_stopped(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    stopped? = s~load_int(1);
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor) | equal_slice_bits(src, halter));

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);
}

() set_instant_mint(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    instant_mint? = s~load_int(1);
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor) | equal_slice_bits(src, halter));

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);
}

() set_governance_fee(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    governance_fee = s~load_uint(16);
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    pack_extension();
}

() set_rounds_imbalance(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    rounds_imbalance = s~load_uint(8);
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor) | equal_slice_bits(src, halter));

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    pack_extension();
}

() send_message_to_loan(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice borrower = s~load_msg_addr();
    int round_since = s~load_uint(32);
    cell message = s~load_ref();
    s.end_parse();

    cell loan_code = loan_codes.find_code(round_since);

    ( builder loan, _, _ ) = create_loan_address(my_address(), borrower.to_builder(), round_since, loan_code);
    int vset_hash = -1;
    int stake_held_until = 0;
    ( slice ps, int f? ) = participations.udict_get?(32, round_since);
    if f? {
        ( _, _, _, _, _, _, _, _, _, _, vset_hash, _, _, stake_held_until ) = unpack_participation(ps);
    }
    int previous = config_param(config::previous_validators).cell_hash();
    int current = config_param(config::current_validators).cell_hash();

    throw_unless(err::access_denied, equal_slice_bits(src, governor) | equal_slice_bits(src, halter));
    throw_unless(err::vset_not_changed, (vset_hash != current) & (vset_hash != previous));
    throw_unless(err::not_ready_to_finish_participation, now() >= stake_held_until);

    send_msg(true, loan, null(), message.begin_parse().to_builder(), 0, send::remaining_value);

    throw(0);
}

() retry_distribute(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    int state = -1;
    ( slice ps, int f? ) = participations.udict_get?(32, round_since);
    if f? {
        ( state, _, _, _, _, _, _, _, _, _, _, _, _, _ ) = unpack_participation(ps);
    }

    throw_unless(err::access_denied, equal_slice_bits(src, governor) | equal_slice_bits(src, halter));
    throw_unless(err::unable_to_participate, state == participation::distributing);

    distribute(query_id, round_since);
}

() retry_recover_stakes(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    int state = -1;
    ( slice ps, int f? ) = participations.udict_get?(32, round_since);
    if f? {
        ( state, _, _, _, _, _, _, _, _, _, _, _, _, _ ) = unpack_participation(ps);
    }

    throw_unless(err::access_denied, equal_slice_bits(src, governor) | equal_slice_bits(src, halter));
    throw_unless(err::unable_to_participate, state == participation::recovering);

    builder continue = begin_cell()
        .store_uint(op::recover_stakes, 32)
        .store_uint(query_id, 64)
        .store_uint(round_since, 32);
    send_msg(false, my_address().to_builder(), null(), continue, max_gas_fee(), send::pay_gas_separately);

    throw(0);
}

() retry_mint_bill(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    int amount = s~load_coins();
    int unstake? = s~load_int(1);
    slice owner = s~load_msg_addr();
    slice fixed_parent = s~load_msg_addr();
    int ownership_assigned_amount = s~load_coins();
    s.end_parse();

    ( slice ps, _ ) = participations.udict_get?(32, round_since);
    ( int state, _, _, _, _, _, _, _, _, _, _, _, _, _ ) = unpack_participation(ps);
    ( _, int fixed_parent_addr ) = parse_std_addr(fixed_parent);
    ( _, int f?) = old_parents.udict_get?(256, fixed_parent_addr);

    throw_unless(err::access_denied, equal_slice_bits(src, governor));
    throw_unless(err::invalid_parameters, equal_slice_bits(fixed_parent, parent) | f?);
    throw_unless(err::invalid_parameters, (state > participation::open) & (state < participation::burning));

    cell collection_code = collection_codes.find_code(round_since);
    cell bill_code = bill_codes.find_code(round_since);

    ( builder collection
    , builder state_init
    , _
    ) = create_collection_address(my_address(), round_since, bill_code, collection_code);

    builder mint = begin_cell()
        .store_uint(op::mint_bill, 32)
        .store_uint(query_id, 64)
        .store_coins(amount)
        .store_int(unstake?, 1)
        .store_slice(owner)
        .store_slice(parent)
        .store_coins(ownership_assigned_amount);
    send_msg(false, collection, state_init, mint, 0, send::remaining_value);

    throw(0);
}

() retry_burn_all(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    int start_index = s~load_uint(64);
    s.end_parse();

    int state = -1;
    ( slice ps, int f? ) = participations.udict_get?(32, round_since);
    if f? {
        ( state, _, _, _, _, _, _, _, _, _, _, _, _, _ ) = unpack_participation(ps);
    }

    throw_unless(err::access_denied, equal_slice_bits(src, governor) | equal_slice_bits(src, halter));
    throw_unless(err::not_ready_to_burn_all, state == participation::burning);

    cell collection_code = collection_codes.find_code(round_since);
    cell bill_code = bill_codes.find_code(round_since);

    ( builder collection, _, _ ) = create_collection_address(my_address(), round_since, bill_code, collection_code);

    builder burn = begin_cell()
        .store_uint(op::burn_all, 32)
        .store_uint(query_id, 64)
        .store_uint(start_index, 64);
    send_msg(false, collection, null(), burn, 0, send::remaining_value);

    throw(0);
}

() set_parent(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice new_parent = s~load_msg_addr();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));
    throw_if(err::invalid_parameters, equal_slice_bits(parent, new_parent));

    ifnot parent.addr_none?() {
        ( _, int parent_addr ) = parse_std_addr(parent);
        old_parents~udict_set_builder(256, parent_addr, begin_cell());
    }
    parent = new_parent;

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    pack_extension();
}

() proxy_set_content(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice destination = s~load_msg_addr();
    cell content = s~load_ref();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));

    builder set = begin_cell()
        .store_uint(op::set_content, 32)
        .store_uint(query_id, 64)
        .store_slice(src)
        .store_ref(content);
    send_msg(true, destination.to_builder(), null(), set, 0, send::remaining_value);

    throw(0);
}

int calculate_min_coins() inline_ref {
    ( int total_fee, _, _ ) = request_loan_fee();
    int k = -1;
    do {
        ( k, slice ps, int f? ) = participations.udict_get_next?(32, k);
        if f? {
            ( int state
            , int size
            , _
            , _
            , _
            , _
            , _
            , _
            , _
            , int total_staked
            , int total_recovered
            , _
            , _
            , _
            ) = unpack_participation(ps);
            if (state >= participation::staked) & (state <= participation::recovering) {
                total_coins -= total_staked;
                total_coins += total_recovered;
            }
            total_coins += size * total_fee;
        }
    } until ~ f?;

    return fee::treasury_storage + total_borrowers_stake + total_staking + total_coins;
}

() withdraw_surplus(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice return_excess = s~load_msg_addr();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));

    raw_reserve(calculate_min_coins(), reserve::exact);

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, return_excess.to_builder(), null(), excess, 0, send::unreserved_balance + send::ignore_errors);

    throw(0);
}

() proxy_withdraw_surplus(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice destination = s~load_msg_addr();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));

    builder withdraw = begin_cell()
        .store_uint(op::withdraw_surplus, 32)
        .store_uint(query_id, 64)
        .store_slice(src);
    send_msg(true, destination.to_builder(), null(), withdraw, 0, send::remaining_value);

    throw(0);
}

() upgrade_data(slice src, int query_id, cell new_data, slice return_excess) impure method_id {
    ;; Add code for upgrading data here.

    ;; This is just a template, and will only run after upgrade_code.
    ;; If data is upgraded, remember to reset this code,
    ;; so that the next upgrade won't change data by mistake.

    ;; Do not change the following code.
    governor = null();
    load_data();
    unpack_extension();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, return_excess.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    throw(0);
}

() upgrade_code(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    cell new_code = s~load_ref();
    cell new_data = s~load_maybe_ref();
    slice return_excess = s~load_msg_addr();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));

    set_code(new_code);
    set_c3(new_code.begin_parse().bless());
    upgrade_data(src, query_id, new_data, return_excess);
}

() proxy_upgrade_code(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice destination = s~load_msg_addr();
    cell new_code = s~load_ref();
    cell new_data = s~load_maybe_ref();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));

    builder upgrade = begin_cell()
        .store_uint(op::upgrade_code, 32)
        .store_uint(query_id, 64)
        .store_ref(new_code)
        .store_maybe_ref(new_data)
        .store_slice(src);
    send_msg(true, destination.to_builder(), null(), upgrade, 0, send::remaining_value);

    throw(0);
}

() send_upgrade_wallet(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice destination = s~load_msg_addr();
    slice owner = s~load_msg_addr();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor) | equal_slice_bits(src, halter));

    builder proxy = begin_cell()
        .store_uint(op::proxy_upgrade_wallet, 32)
        .store_uint(query_id, 64)
        .store_slice(owner);
    send_msg(false, destination.to_builder(), null(), proxy, 0, send::remaining_value);

    throw(0);
}

() migrate_wallet(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    slice owner = s~load_msg_addr();
    s.end_parse();

    ( int src_wc, int src_addr ) = parse_std_addr(src);
    ( _, int f? ) = old_parents.udict_get?(256, src_addr);
    int fee = merge_wallet_fee();
    int incoming_ton = get_incoming_value().pair_first();
    int enough_fee? = incoming_ton >= fee;

    ;; send back if src is not one of the old parents.
    slice destination = src;
    if enough_fee? & f? & (src_wc == chain::base) {
        destination = parent;
    }

    builder merge = begin_cell()
        .store_uint(op::proxy_merge_wallet, 32)
        .store_uint(query_id, 64)
        .store_coins(tokens)
        .store_slice(owner);
    send_msg(false, destination.to_builder(), null(), merge, 0, send::remaining_value);

    throw(0);
}

() proxy_add_library(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice destination = s~load_msg_addr();
    cell code = s~load_ref();
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));

    builder library = begin_cell()
        .store_uint(op::add_library, 32)
        .store_uint(query_id, 64)
        .store_ref(code);
    send_msg(false, destination.to_builder(), null(), library, 0, send::remaining_value);

    throw(0);
}

() proxy_remove_library(slice src, slice s) impure inline {
    unpack_extension();

    int query_id = s~load_uint(64);
    slice destination = s~load_msg_addr();
    int code_hash = s~load_uint(256);
    s.end_parse();

    throw_unless(err::access_denied, equal_slice_bits(src, governor));

    builder library = begin_cell()
        .store_uint(op::remove_library, 32)
        .store_uint(query_id, 64)
        .store_uint(code_hash, 256);
    send_msg(false, destination.to_builder(), null(), library, 0, send::remaining_value);

    throw(0);
}

() gift_coins(slice src, slice s) impure inline {
    int query_id = s~load_uint(64);
    int coins = s~load_coins();
    s.end_parse();

    if total_tokens {
        total_coins += coins;
    } else {
        coins = 0;
    }

    raw_reserve(coins, reserve::add_original_balance);

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::unreserved_balance + send::ignore_errors);
}

() on_bounce(slice src, slice s) impure inline {
    s~skip_bits(32);
    int op = s~load_uint(32);
    int query_id = s~load_uint(64);

    throw(0); ;; just accept bounced TON
}

() route_internal_message(int flags, slice src, slice s) impure inline {
    if flags & 1 {
        return on_bounce(src, s);
    }

    int op = 0;
    if s.slice_bits() {
        op = s~load_uint(32);
    }

    if op == op::deposit_coins {
        return deposit_coins(src, s);
    }

    if op == op::send_unstake_all {
        return send_unstake_all(src, s);
    }

    if op == op::reserve_tokens {
        return reserve_tokens(src, s);
    }

    if op == op::mint_tokens {
        return mint_tokens(src, s);
    }

    if op == op::burn_tokens {
        return burn_tokens(src, s);
    }

    if op == op::provide_current_quote {
        return provide_current_quote(src, s);
    }

    if op == op::request_loan {
        return request_loan(src, s);
    }

    if op == op::participate_in_election {
        return participate_in_election(s);
    }

    if op == op::decide_loan_requests {
        return decide_loan_requests(src, s);
    }

    if op == op::process_loan_requests {
        return process_loan_requests(src, s);
    }

    if op == op::vset_changed {
        return vset_changed(s);
    }

    if op == op::finish_participation {
        return finish_participation(s);
    }

    if op == op::recover_stakes {
        return recover_stakes(src, s);
    }

    if op == op::recover_stake_result {
        return recover_stake_result(src, s);
    }

    if op == op::last_bill_burned {
        return last_bill_burned(src, s);
    }

    if op == op::propose_governor {
        return propose_governor(src, s);
    }

    if op == op::accept_governance {
        return accept_governance(src, s);
    }

    if op == op::set_halter {
        return set_halter(src, s);
    }

    if op == op::set_stopped {
        return set_stopped(src, s);
    }

    if op == op::set_instant_mint {
        return set_instant_mint(src, s);
    }

    if op == op::set_governance_fee {
        return set_governance_fee(src, s);
    }

    if op == op::set_rounds_imbalance {
        return set_rounds_imbalance(src, s);
    }

    if op == op::send_message_to_loan {
        return send_message_to_loan(src, s);
    }

    if op == op::retry_distribute {
        return retry_distribute(src, s);
    }

    if op == op::retry_recover_stakes {
        return retry_recover_stakes(src, s);
    }

    if op == op::retry_mint_bill {
        return retry_mint_bill(src, s);
    }

    if op == op::retry_burn_all {
        return retry_burn_all(src, s);
    }

    if op == op::set_parent {
        return set_parent(src, s);
    }

    if op == op::proxy_set_content {
        return proxy_set_content(src, s);
    }

    if op == op::withdraw_surplus {
        return withdraw_surplus(src, s);
    }

    if op == op::proxy_withdraw_surplus {
        return proxy_withdraw_surplus(src, s);
    }

    if op == op::upgrade_code {
        return upgrade_code(src, s);
    }

    if op == op::proxy_upgrade_code {
        return proxy_upgrade_code(src, s);
    }

    if op == op::send_upgrade_wallet {
        return send_upgrade_wallet(src, s);
    }

    if op == op::migrate_wallet {
        return migrate_wallet(src, s);
    }

    if op == op::proxy_add_library {
        return proxy_add_library(src, s);
    }

    if op == op::proxy_remove_library {
        return proxy_remove_library(src, s);
    }

    if op == op::gift_coins {
        return gift_coins(src, s);
    }

    if op == op::top_up {
        throw(0); ;; top up TON balance, do nothing
    }

    if op == 0 {
        int c = s~load_uint(8);
        s.end_parse();
        c |= 0x20; ;; convert to lowercase

        if c == "d"u {
            return deposit_coins(src, "0000000000000000000"s);
        }

        if c == "w"u {
            return send_unstake_all(src, "0000000000000000"s);
        }

        throw(err::invalid_comment);
    }

    throw(err::invalid_op);
}

() route_external_message(slice s) impure inline {
    int op = s~load_uint(32);

    if op == op::participate_in_election {
        return participate_in_election(s);
    }

    if op == op::vset_changed {
        return vset_changed(s);
    }

    if op == op::finish_participation {
        return finish_participation(s);
    }

    throw(err::invalid_op);
}

() recv_internal(cell in_msg_full, slice s) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice src = cs~load_msg_addr();

    load_data();
    route_internal_message(flags, src, s);
    save_data();
}

() recv_external(slice s) impure {
    load_data();
    route_external_message(s);
    save_data();
}

;;
;; get methods
;;

var get_treasury_state() method_id {
    load_data();
    unpack_extension();

    return
        ( total_coins
        , total_tokens
        , total_staking
        , total_unstaking
        , total_borrowers_stake
        , parent
        , participations
        , rounds_imbalance
        , stopped?
        , instant_mint?
        , loan_codes
        , last_staked
        , last_recovered
        , halter
        , governor
        , proposed_governor
        , governance_fee
        , collection_codes
        , bill_codes
        , old_parents
        );
}

var get_participation(int round_since) method_id {
    load_data();

    ( slice ps, _ ) = participations.udict_get?(32, round_since);
    return unpack_participation(ps);
}

slice get_collection_address(int round_since) method_id {
    load_data();
    unpack_extension();

    cell collection_code = collection_codes.find_code(round_since);
    cell bill_code = bill_codes.find_code(round_since);

    ( builder collection, _, _ ) = create_collection_address(my_address(), round_since, bill_code, collection_code);

    return collection.end_cell().begin_parse();
}

slice get_bill_address(int round_since, int index) method_id {
    load_data();
    unpack_extension();

    cell collection_code = collection_codes.find_code(round_since);
    cell bill_code = bill_codes.find_code(round_since);

    ( builder collection, _, _ ) = create_collection_address(my_address(), round_since, bill_code, collection_code);
    ( builder bill, _, _ ) = create_bill_address(index, collection.end_cell().begin_parse(), bill_code);

    return bill.end_cell().begin_parse();
}

slice get_loan_address(slice borrower, int round_since) method_id {
    load_data();

    ( int borrower_wc, _ ) = parse_std_addr(borrower);

    throw_unless(err::only_basechain_allowed, borrower_wc == chain::base);

    cell loan_code = loan_codes.find_code(round_since);

    ( builder loan, _, _ ) = create_loan_address(my_address(), borrower.to_builder(), round_since, loan_code);

    return loan.end_cell().begin_parse();
}

var get_treasury_fees(int ownership_assigned_amount) method_id {
    ( int deposit_fee, _ ) = deposit_coins_fee(ownership_assigned_amount);
    ( int loan_fee, _, _ ) = request_loan_fee();
    return
        ( loan_fee
        , deposit_fee
        , unstake_all_fee()
        );
}

int get_max_burnable_tokens() method_id {
    load_data();

    int ton_balance = get_balance().pair_first();
    int available_ton = ton_balance - fee::treasury_storage - total_borrowers_stake;
    int burnable_tokens = 0;

    if total_coins {
        burnable_tokens = muldiv(available_ton, total_tokens, total_coins);
    }

    return burnable_tokens;
}

int get_surplus() method_id {
    load_data();
    unpack_extension();

    int ton_balance = get_balance().pair_first();
    int min_coins = calculate_min_coins();

    return ton_balance - min_coins;
}

int get_max_punishment(int stake) method_id {
    return max_recommended_punishment_for_validator_misbehaviour(stake);
}
