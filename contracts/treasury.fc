#include "imports/utils.fc";

builder pack_loan
    ( int min_payment
    , int validator_reward_share
    , int loan_amount
    , int accrue_amount
    , int stake_amount
    , cell new_stake_msg
    ) {
    return begin_cell()
        .store_coins(min_payment)
        .store_uint(validator_reward_share, 8)
        .store_coins(loan_amount)
        .store_coins(accrue_amount)
        .store_coins(stake_amount)
        .store_ref(new_stake_msg);
}

(int, int, int, int, int, cell) unpack_loan(slice s) {
    int min_payment = s~load_coins();
    int validator_reward_share = s~load_uint(8);
    int loan_amount = s~load_coins();
    int accrue_amount = s~load_coins();
    int stake_amount = s~load_coins();
    cell new_stake_msg = s~load_ref();
    s.end_parse();
    return ( min_payment, validator_reward_share, loan_amount, accrue_amount, stake_amount, new_stake_msg );
}

builder pack_participation
    ( int state
    , cell sorted
    , int loans_size
    , cell requests
    , cell accepted
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) {
    return begin_cell()
        .store_uint(state, 3)
        .store_dict(sorted)
        .store_uint(loans_size, 16)
        .store_dict(requests)
        .store_dict(accepted)
        .store_dict(staked)
        .store_dict(recovering)
        .store_coins(total_staked)
        .store_coins(total_recovered)
        .store_uint(current_vset_hash, 256)
        .store_uint(stake_held_for, 32)
        .store_uint(stake_held_until, 32);
}

(int, cell, int, cell, cell, cell, cell, int, int, int, int, int) unpack_participation(slice s) {
    int state = s~load_uint(3);
    cell sorted = s~load_dict();
    int loans_size = s~load_uint(16);
    cell requests = s~load_dict();
    cell accepted = s~load_dict();
    cell staked = s~load_dict();
    cell recovering = s~load_dict();
    int total_staked = s~load_coins();
    int total_recovered = s~load_coins();
    int current_vset_hash = s~load_uint(256);
    int stake_held_for = s~load_uint(32);
    int stake_held_until = s~load_uint(32);
    s.end_parse();
    return
        ( state
        , sorted
        , loans_size
        , requests
        , accepted
        , staked
        , recovering
        , total_staked
        , total_recovered
        , current_vset_hash
        , stake_held_for
        , stake_held_until
        );
}

builder pack_extension
    ( slice driver
    , slice halter
    , slice governor
    , cell proposed_governor
    , int reward_share
    , cell rewards_history
    , cell content
    ) {
    return begin_cell()
        .store_slice(driver)
        .store_slice(halter)
        .store_slice(governor)
        .store_maybe_ref(proposed_governor)
        .store_uint(reward_share, 16)
        .store_dict(rewards_history)
        .store_ref(content);
}

(slice, slice, slice, cell, int, cell, cell) unpack_extension(slice s) {
    slice driver = s~load_msg_addr();
    slice halter = s~load_msg_addr();
    slice governor = s~load_msg_addr();
    cell proposed_governor = s~load_maybe_ref();
    int reward_share = s~load_uint(16);
    cell rewards_history = s~load_dict();
    cell content = s~load_ref();
    s.end_parse();
    return
        ( driver
        , halter
        , governor
        , proposed_governor
        , reward_share
        , rewards_history
        , content
        );
}

() save_data
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) impure {
    begin_cell()
        .store_coins(total_coins)
        .store_coins(total_tokens)
        .store_coins(total_staking)
        .store_coins(total_unstaking)
        .store_coins(total_validators_stake)
        .store_dict(participations)
        .store_int(stopped?, 1)
        .store_ref(wallet_code)
        .store_ref(loan_code)
        .store_ref(extension)
        .end_cell()
        .set_data();
}

(int, int, int, int, int, cell, int, cell, cell, cell) load_data() impure {
    slice ds = get_data().begin_parse();
    int total_coins = ds~load_coins();
    int total_tokens = ds~load_coins();
    int total_staking = ds~load_coins();
    int total_unstaking = ds~load_coins();
    int total_validators_stake = ds~load_coins();
    cell participations = ds~load_dict();
    int stopped? = ds~load_int(1);
    cell wallet_code = ds~load_ref();
    cell loan_code = ds~load_ref();
    cell extension = ds~load_ref();
    return
        ( total_coins
        , total_tokens
        , total_staking
        , total_unstaking
        , total_validators_stake
        , participations
        , stopped?
        , wallet_code
        , loan_code
        , extension
        );
}

() deposit_coins(int msg_ton, slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( slice driver, _, _, _, _, _, _ ) = unpack_extension(extension.begin_parse());

    int query_id = s~load_uint(64);
    s.end_parse();

    ( builder wallet, cell state_init, _ ) = create_wallet_address(src.to_builder(), my_address(), wallet_code);
    ( int src_wc, _ ) = parse_std_addr(src);
    int min_fee = deposit_coins_fee(state_init);
    int storage_fee = 0; ;; todo
    int stake_amount = msg_ton - storage_fee - min_fee;

    throw_unless(err::only_basechain_allowed, src_wc == chain::base);
    throw_unless(err::insufficient_fee, stake_amount > 0);
    throw_unless(err::stopped, ~ stopped?);

    int round_since = 1 << 32;
    do {
        ( round_since, slice v, int f? ) = participations.udict_get_prev?(32, round_since);
        if (f?) {
            int state = v~load_uint(3);
            if (state > participation::open) {
                ;; stake after rewards for this round has been distributed
                f? = false;
            }
        }
    } until (~ f?);
    if (round_since.null?()) {
        round_since = 0;
    }

    total_staking += stake_amount;

    raw_reserve(stake_amount, reserve::add_original_balance);

    builder body = begin_cell()
        .store_uint(op::save_coins, 32)
        .store_uint(query_id, 64)
        .store_coins(stake_amount)
        .store_uint(round_since, 32)
        .store_slice(driver);
    send_msg(true, wallet, state_init, body, 0, send::remaining_balance);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() mint_tokens(int msg_ton, slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    int query_id = s~load_uint(64);
    int stake_amount = s~load_coins();
    int round_since = s~load_uint(32);
    slice owner = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    s.end_parse();

    ( builder wallet, _, int wallet_addr ) = create_wallet_address(owner.to_builder(), my_address(), wallet_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::base) & (src_addr == wallet_addr));

    ( _, int f?) = participations.udict_get?(32, round_since);
    if (f?) {
        ;; too soon, rewards are not yet distributed
        builder body = begin_cell()
            .store_uint(op::save_coins, 32)
            .store_uint(query_id, 64)
            .store_coins(stake_amount)
            .store_uint(round_since, 32)
            .store_slice(return_excess);
        send_msg(true, wallet, null(), body, 0, send::remaining_value);

        return ();
    }

    int tokens = stake_amount;
    if (total_coins > 0) {
        tokens = muldiv(stake_amount, total_tokens, total_coins);
    }

    total_staking -= stake_amount;
    total_coins += stake_amount;
    total_tokens += tokens;

    builder body = begin_cell()
        .store_uint(op::receive_tokens, 32)
        .store_uint(query_id, 64)
        .store_coins(tokens)
        .store_slice(owner)
        .store_slice(return_excess)
        .store_coins(transfer_notification_fee())
        .store_uint(0, 1); ;; empty forward_payload
    send_msg(false, wallet, null(), body, 0, send::remaining_value);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() reserve_tokens(int msg_ton, slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( slice driver, _, _, _, _, _, _ ) = unpack_extension(extension.begin_parse());

    int query_id = s~load_uint(64);
    int amount = s~load_coins();
    slice owner = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    s.end_parse();

    ( _, _, int wallet_addr ) = create_wallet_address(owner.to_builder(), my_address(), wallet_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::base) & (src_addr == wallet_addr));

    total_unstaking += amount;

    raw_reserve(0, reserve::add_original_balance);

    builder fee = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, driver.to_builder(), null(), fee, withdraw_tokens_fee(), send::pay_gas_separately);

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, return_excess.to_builder(), null(), excess, 0, send::remaining_balance + send::ignore_errors);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() burn_tokens(int msg_ton, slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    int query_id = s~load_uint(64);
    int tokens = s~load_coins();
    slice owner = s~load_msg_addr();
    slice return_excess = s~load_msg_addr();
    s.end_parse();

    ( builder wallet, _, int wallet_addr ) = create_wallet_address(owner.to_builder(), my_address(), wallet_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::base) & (src_addr == wallet_addr));

    int ton_balance = get_balance().pair_first();
    int ton_balance_before_msg = ton_balance - msg_ton;
    int available_ton = ton_balance_before_msg - fee::treasury_storage - total_validators_stake;

    int withdrawal_amount = tokens;
    if (total_tokens > 0) {
        withdrawal_amount = muldiv(tokens, total_coins, total_tokens);
    }

    if (withdrawal_amount > available_ton) {
        ;; insufficient funds for now, return back tokens
        builder body = begin_cell()
            .store_uint(op::burn_failed, 32)
            .store_uint(query_id, 64)
            .store_coins(tokens)
            .store_slice(return_excess);
        send_msg(false, wallet, null(), body, 0, send::remaining_value);

        return ();
    }

    total_coins -= withdrawal_amount;
    total_tokens -= tokens;
    total_unstaking -= tokens;
    if ((total_coins == 0) | (total_tokens == 0)) {
        total_coins = 0;
        total_tokens = 0;
    }

    raw_reserve(withdrawal_amount, reserve::negate + reserve::add_original_balance);

    builder body = begin_cell()
        .store_uint(op::withdrawal_notification, 32)
        .store_uint(query_id, 64);
    send_msg(false, owner.to_builder(), null(), body, withdrawal_amount, send::pay_gas_separately);

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, return_excess.to_builder(), null(), excess, 0, send::remaining_balance + send::ignore_errors);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() send_stake_first_coins(slice src) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    ( builder wallet, _, _ ) = create_wallet_address(src.to_builder(), my_address(), wallet_code);
    ( int src_wc, _ ) = parse_std_addr(src);

    throw_unless(err::only_basechain_allowed, src_wc == chain::base);

    builder body = begin_cell()
        .store_uint(op::stake_first_coins, 32)
        .store_uint(0, 64)
        .store_slice(src);
    send_msg(false, wallet, null(), body, 0, send::remaining_value);
}

() send_unstake_all_tokens(slice src) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    ( builder wallet, _, _ ) = create_wallet_address(src.to_builder(), my_address(), wallet_code);
    ( int src_wc, _ ) = parse_std_addr(src);

    throw_unless(err::only_basechain_allowed, src_wc == chain::base);

    builder body = begin_cell()
        .store_uint(op::unstake_all_tokens, 32)
        .store_uint(0, 64)
        .store_slice(src);
    send_msg(false, wallet, null(), body, 0, send::remaining_value);
}

() send_withdraw_tokens(slice src) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    ( builder wallet, _, _ ) = create_wallet_address(src.to_builder(), my_address(), wallet_code);
    ( int src_wc, _ ) = parse_std_addr(src);

    throw_unless(err::only_basechain_allowed, src_wc == chain::base);

    builder body = begin_cell()
        .store_uint(op::withdraw_tokens, 32)
        .store_uint(0, 64)
        .store_slice(src);
    send_msg(false, wallet, null(), body, 0, send::remaining_value);
}

() provide_wallet_address(slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    int query_id = s~load_uint(64);
    slice owner = s~load_msg_addr();
    int include_address? = s~load_int(1);
    s.end_parse();

    builder wallet = begin_cell().store_uint(0, 2); ;; addr_none;
    ( int owner_wc, _ ) = parse_std_addr(owner);
    if (owner_wc == chain::base) {
        ( wallet, _, _ ) = create_wallet_address(owner.to_builder(), my_address(), wallet_code);
    }

    cell included_address = include_address?
        ? owner.to_builder().end_cell()
        : null();

    builder body = begin_cell()
        .store_uint(op::take_wallet_address, 32)
        .store_uint(query_id, 64)
        .store_builder(wallet)
        .store_maybe_ref(included_address);
    send_msg(false, src.to_builder(), null(), body, 0, send::remaining_value);
}

(int, int, int, int, int, int) get_times() impure method_id {
    ( int current_round_since, int next_round_since ) = get_vset_times(config::current_validators);
    ( int validators_elected_for
    , int elections_start_before
    , int elections_end_before
    , int stake_held_for
    ) = get_election_config();
    int election_span = elections_start_before - elections_end_before;
    int election_end = next_round_since - elections_end_before;
    int participate_since = election_end - max(600, muldiv(election_span, 10, 100));
    int participate_until = election_end - 300;
    int next_round_until = next_round_since + validators_elected_for;
    return
        ( current_round_since
        , participate_since
        , participate_until
        , next_round_since
        , next_round_until
        , stake_held_for
        );
}

() request_loan(int msg_ton, slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    int loan_amount = s~load_coins();
    int min_payment = s~load_coins();
    int validator_reward_share = s~load_uint(8);
    cell new_stake_msg = s~load_ref();
    s.end_parse();
    check_new_stake_msg(new_stake_msg.begin_parse());

    ( int validator_wc, int validator_addr ) = parse_std_addr(src);
    ( int min_stake, _, _, _ ) = get_stake_config();
    ( _, int next_round_since ) = get_vset_times(config::current_validators);
    int state = participation::open;
    cell sorted = new_dict();
    int loans_size = 0;
    cell requests = new_dict();
    int old_stake_amount = 0;
    ( slice pd, int f? ) = participations.udict_get?(32, next_round_since);
    if (f?) {
        ( state, sorted, loans_size, requests, _, _, _, _, _, _, _, _ ) = unpack_participation(pd);
        ( slice old_request, int e? ) = requests~udict_delete_get?(256, validator_addr);
        if (e?) {
            loans_size -= 1;
            ;; clean up old request
            ( int old_min_payment
            , int old_validator_reward_share
            , int old_loan_amount
            , _
            , old_stake_amount
            , _
            ) = unpack_loan(old_request);

            int old_sort_key = loan_sort_key(old_min_payment, old_validator_reward_share, old_loan_amount);
            ( cell old_bucket, _ ) = sorted.udict_get_ref?(112, old_sort_key);
            old_bucket~udict_delete?(256, validator_addr);
            if (old_bucket.null?()) {
                sorted~udict_delete?(112, old_sort_key);
            } else {
                sorted~udict_set_ref(112, old_sort_key, old_bucket);
            }
        }
    }
    ( _, cell state_init, _ ) = create_loan_address(my_address(), src.to_builder(), round_since, loan_code);
    int fee = request_loan_fee(state_init);
    int stake_amount = msg_ton - fee + old_stake_amount;
    total_validators_stake += stake_amount - old_stake_amount;
    int max_punishment = max_recommended_punishment_for_validator_misbehaviour(loan_amount + stake_amount);
    ( _, int participate_since, _, _, _, _ ) = get_times();

    throw_unless(err::access_denied, validator_wc == chain::base);
    throw_unless(err::not_accepting_loan_requests, state == participation::open);
    throw_unless(err::not_accepting_loan_requests, round_since == next_round_since);
    throw_unless(err::not_accepting_loan_requests, now() < participate_since);
    throw_unless(err::insufficient_funds, stake_amount + loan_amount >= min_stake + fee::new_stake_confirmation);
    throw_unless(err::insufficient_funds, stake_amount >= min_payment + max_punishment);
    throw_unless(err::stopped, ~ stopped?);

    builder request = pack_loan(min_payment, validator_reward_share, loan_amount, 0, stake_amount, new_stake_msg);
    requests~udict_set_builder(256, validator_addr, request);
    loans_size += 1;

    int sort_key = loan_sort_key(min_payment, validator_reward_share, loan_amount);
    ( cell bucket, _ ) = sorted.udict_get_ref?(112, sort_key);
    bucket~udict_set_builder(256, validator_addr, begin_cell());
    sorted~udict_set_ref(112, sort_key, bucket);

    ( int max_validators, _, _ ) = get_validators_config();
    if (loans_size > max_validators) {
        ( int last_sort_key, slice v, _ ) = sorted~udict_delete_get_min?(112);
        cell last_bucket = v~load_ref();
        ( int last_validator_addr, _, _ ) = last_bucket~udict_delete_get_max?(256);
        ( slice last_request, _ ) = requests~udict_delete_get?(256, last_validator_addr);
        loans_size -= 1;
        ifnot (last_bucket.null?()) {
            sorted~udict_set_ref(112, last_sort_key, last_bucket);
        }
        builder last_validator = create_address(chain::base, last_validator_addr);
        ( _, _, _, _, int last_stake_amount, _ ) = unpack_loan(last_request);
        total_validators_stake -= last_stake_amount;
        send_msg(false, last_validator, null(), begin_cell(), last_stake_amount, send::pay_gas_separately);
    }

    builder pdb = pack_participation(
        state, sorted, loans_size, requests, new_dict(), new_dict(), new_dict(), 0, 0, 0, 0, 0
    );
    participations~udict_set_builder(32, next_round_since, pdb);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

(cell, cell, int) decide_on_loans(cell sorted, cell requests, int participate_until, int available) impure {
    cell accepted = new_dict();
    int accepted_size = 0;
    int allocated = 0;

    int elected? = ~ config_param(config::next_validators).null?();
    int too_late? = now() > participate_until;
    if (elected? | too_late?) {
        ;; reject all loans if already elected or there is not enough time for safe participation
        return ( requests, accepted, accepted_size );
    }

    int k = 1 << 112;
    do {
        ;; sorted is in ascending order, read from the end
        ( k, slice v, int f? ) = sorted.udict_get_prev?(112, k);
        if (f?) {
            cell bucket = v~load_ref();
            int validator_addr = -1;
            do {
                ( validator_addr, _, int e? ) = bucket.udict_get_next?(256, validator_addr);
                if (e?) {
                    ( slice request, _ ) = requests.udict_get?(256, validator_addr);
                    ( _, _, int loan_amount, _, _, _ ) = unpack_loan(request);
                    if (available >= loan_amount) {
                        available -= loan_amount;
                        allocated += loan_amount;
                        accepted_size += 1;
                        accepted~udict_set(256, validator_addr, request);
                        requests~udict_delete?(256, validator_addr);
                    }
                }
            } until (~ e?);
        }
    } until (~ f?);

    ;; distribute remaining coins between accepted requests, when they have enough stake
    k = -1;
    do {
        ( k, slice v, int f? ) = accepted.udict_get_next?(256, k);
        if (f?) {
            ( int min_payment
            , int validator_reward_share
            , int loan_amount
            , _
            , int stake_amount
            , cell new_stake_msg
            ) = unpack_loan(v);
            int accrue_amount = muldiv(available, loan_amount, allocated);
            int total_loan_amount = loan_amount + accrue_amount + stake_amount;
            int max_punishment = max_recommended_punishment_for_validator_misbehaviour(total_loan_amount);
            if (stake_amount >= min_payment + max_punishment) {
                builder request = pack_loan(
                    min_payment, validator_reward_share, loan_amount, accrue_amount, stake_amount, new_stake_msg
                );
                accepted~udict_set_builder(256, k, request);
            }
        }
    } until (~ f?);

    return ( requests, accepted, accepted_size );
}

() participate_in_election(slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ifnot (query_id) {
        ;; force reply from elector when staking
        query_id = now() << 32;
    }
    int state = -1;
    cell sorted = new_dict();
    int loans_size = 0;
    cell requests = new_dict();
    ( slice pd, int f? ) = participations.udict_get?(32, round_since);
    if (f?) {
        ( state, sorted, loans_size, requests, _, _, _, _, _, _, _, _ ) = unpack_participation(pd);
    }
    ( _, int participate_since, int participate_until, _, int next_round_until, int stake_held_for ) = get_times();

    throw_unless(err::unable_to_participate, state == participation::open);
    throw_unless(err::too_soon_to_participate, now() >= participate_since);

    accept_message();

    state = participation::distribution;

    int reserved_amount = total_unstaking;
    if (total_tokens > 0) {
        reserved_amount = muldiv(total_unstaking, total_coins, total_tokens);
    }
    ( _, cell state_init, _ ) = create_loan_address(my_address(), my_address().to_builder(), round_since, loan_code);
    int fee = request_loan_fee(state_init);
    int ton_balance = get_balance().pair_first();
    int available = ton_balance - fee::treasury_storage - total_validators_stake - loans_size * fee - reserved_amount;

    ( requests, cell accepted, int accepted_size ) = decide_on_loans(sorted, requests, participate_until, available);
    int current_vset_hash = config_param(config::current_validators).cell_hash();
    int stake_held_until = next_round_until + stake_held_for + 60;
    builder pdb = pack_participation(
        state, new_dict(), accepted_size, requests, accepted, new_dict(), new_dict(), 0, 0,
        current_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pdb);

    builder body = begin_cell()
        .store_uint(op::process_loan_requests, 32)
        .store_uint(query_id, 64)
        .store_uint(round_since, 32);
    send_msg(false, my_address().to_builder(), null(), body, fee, send::pay_gas_separately);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() process_loan_requests(int msg_ton, slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice pd, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , _
    , int loans_size
    , cell requests
    , cell accepted
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(pd);

    throw_unless(err::access_denied, equal_slices(src, my_address()));

    accept_message();

    int remain = 255 - 1; ;; keep the last one for continue message

    ;; send new stake message for each accepted loan
    while ((~ dict_empty?(accepted)) & (remain > 0)) {
        ( int validator_addr, slice request, int f? ) = accepted~udict_delete_get_min?(256);
        if (f?) {
            ( _, _, int loan_amount, int accrue_amount, int stake_amount, cell new_stake_msg ) = unpack_loan(request);
            builder validator = create_address(chain::base, validator_addr);
            ( builder loan, cell state_init, _ ) = create_loan_address(my_address(), validator, round_since, loan_code);
            int fee = send_new_stake_fee(state_init);
            int ton_amount = loan_amount + accrue_amount + stake_amount + fee;
            total_staked += loan_amount + accrue_amount;
            staked~udict_set(256, validator_addr, request);
            total_validators_stake -= stake_amount;
            remain -= 1;

            builder body = begin_cell()
                .store_uint(op::send_new_stake, 32)
                .store_uint(query_id, 64)
                .store_ref(new_stake_msg);
            send_msg(true, loan, state_init, body, ton_amount, send::pay_gas_separately);
        }
    }

    ;; return staked amount of rejected requests
    while ((~ dict_empty?(requests)) & (remain > 0)) {
        ( int validator_addr, slice request, int f? ) = requests~udict_delete_get_min?(256);
        if (f?) {
            ( _, _, _, _, int stake_amount, _ ) = unpack_loan(request);
            builder validator = create_address(chain::base, validator_addr);
            total_validators_stake -= stake_amount;
            remain -= 1;

            send_msg(false, validator, null(), begin_cell(), stake_amount, send::pay_gas_separately);
        }
    }

    ifnot (dict_empty?(requests) & dict_empty?(accepted)) {
        ;; continue sending messages until done
        builder body = begin_cell()
            .store_uint(op::process_loan_requests, 32)
            .store_uint(query_id, 64)
            .store_uint(round_since, 32);
        send_msg(false, my_address().to_builder(), null(), body, msg_ton, send::pay_gas_separately);
    } else {
        state = participation::staked;
    }

    if (dict_empty?(requests) & dict_empty?(accepted) & dict_empty?(staked)) {
        ;; no loans accepted, remove empty participation data
        participations~udict_delete?(32, round_since);
    } else {
        builder pdb = pack_participation(
            state, new_dict(), loans_size, requests, accepted, staked, recovering, total_staked, total_recovered,
            current_vset_hash, stake_held_for, stake_held_until
        );
        participations~udict_set_builder(32, round_since, pdb);
    }

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() new_stake_rejected(int msg_ton, slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    int query_id = s~load_uint(64);
    int reason = s~load_uint(32);
    slice validator = s~load_msg_addr();
    int round_since = s~load_uint(32);
    s.end_parse();

    ( _
    , cell state_init
    , int loan_addr
    ) = create_loan_address(my_address(), validator.to_builder(), round_since, loan_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);
    ( _, int validator_addr ) = parse_std_addr(validator);

    throw_unless(err::access_denied, (src_wc == chain::main) & (src_addr == loan_addr));

    accept_message();

    ( slice pd, int f? ) = participations.udict_get?(32, round_since);
    if (f?) {
        ( int state
        , _
        , int loans_size
        , cell requests
        , cell accepted
        , cell staked
        , cell recovering
        , int total_staked
        , int total_recovered
        , int current_vset_hash
        , int stake_held_for
        , int stake_held_until
        ) = unpack_participation(pd);
        ( slice request, int e? ) = staked~udict_delete_get?(256, validator_addr);
        if (e?) {
            ( int min_payment, _, int loan_amount, int accrue_amount, int stake_amount, _ ) = unpack_loan(request);

            if (msg_ton >= loan_amount + accrue_amount + min_payment) {
                total_recovered += loan_amount + accrue_amount + min_payment;
                int amount = min(stake_amount - min_payment, msg_ton - loan_amount - accrue_amount - min_payment);

                send_msg(false, validator.to_builder(), null(), begin_cell(), amount, send::ignore_errors);
            } else {
                total_recovered += msg_ton;
            }
        } else {
            total_recovered += msg_ton;
        }

        builder pdb = pack_participation(
            state, new_dict(), loans_size, requests, accepted, staked, recovering, total_staked, total_recovered,
            current_vset_hash, stake_held_for, stake_held_until
        );
        participations~udict_set_builder(32, round_since, pdb);
    }

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() vset_changed(slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice pd, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , _
    , int loans_size
    , cell requests
    , cell accepted
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(pd);
    int new_vset_hash = config_param(config::current_validators).cell_hash();

    throw_unless(err::vset_not_changed, new_vset_hash != current_vset_hash);
    throw_unless(err::vset_not_changeable, (state == participation::staked) | (state == participation::validating));

    accept_message();

    if (state == participation::staked) {
        state = participation::validating;
        ( _, int next_round_since ) = get_vset_times(config::current_validators);
        stake_held_until = next_round_since + stake_held_for + 60;
    } else {
        state = participation::held;
        stake_held_until = now() + stake_held_for + 60;
    }

    builder pdb = pack_participation(
        state, new_dict(), loans_size, requests, accepted, staked, recovering, total_staked, total_recovered,
        new_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pdb);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() finish_participation(slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice pd, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , _
    , int loans_size
    , cell requests
    , cell accepted
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(pd);

    throw_unless(err::not_ready_to_finish_participation, state == participation::held);
    throw_unless(err::too_soon_to_finish_participation, now() >= stake_held_until);

    accept_message();

    state = participation::recovering;

    builder pdb = pack_participation(
        state, new_dict(), loans_size, requests, accepted, staked, recovering, total_staked, total_recovered,
        current_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pdb);

    ( _, cell state_init, _ ) = create_loan_address(my_address(), my_address().to_builder(), round_since, loan_code);
    int fee = request_loan_fee(state_init);

    builder body = begin_cell()
        .store_uint(op::recover_stakes, 32)
        .store_uint(query_id, 64)
        .store_uint(round_since, 32);
    send_msg(false, my_address().to_builder(), null(), body, fee, send::pay_gas_separately);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() recover_stakes(int msg_ton, slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    int query_id = s~load_uint(64);
    int round_since = s~load_uint(32);
    s.end_parse();

    ( slice pd, _ ) = participations.udict_get?(32, round_since);
    ( int state
    , _
    , int loans_size
    , cell requests
    , cell accepted
    , cell staked
    , cell recovering
    , int total_staked
    , int total_recovered
    , int current_vset_hash
    , int stake_held_for
    , int stake_held_until
    ) = unpack_participation(pd);

    int fee = recover_stake_fee();

    throw_unless(err::access_denied, equal_slices(src, my_address()));

    accept_message();

    int remain = 255 - 1; ;; keep the last one for continue message

    ;; send recover stake message from each given loan
    while ((~ dict_empty?(staked)) & (remain > 0)) {
        ( int validator_addr, slice request, int f? ) = staked~udict_delete_get_min?(256);
        if (f?) {
            remain -= 1;
            recovering~udict_set(256, validator_addr, request);
            builder validator = create_address(chain::base, validator_addr);
            ( builder loan, _, _ ) = create_loan_address(my_address(), validator, round_since, loan_code);

            builder body = begin_cell()
                .store_uint(op::send_recover_stake, 32)
                .store_uint(query_id, 64);
            send_msg(true, loan, null(), body, fee, send::pay_gas_separately);
        }
    }

    ifnot (dict_empty?(staked)) {
        ;; continue sending messages until done
        builder body = begin_cell()
            .store_uint(op::recover_stakes, 32)
            .store_uint(query_id, 64)
            .store_int(round_since, 32);
        send_msg(false, my_address().to_builder(), null(), body, msg_ton, send::pay_gas_separately);
    }

    builder pdb = pack_participation(
        state, new_dict(), loans_size, requests, accepted, staked, recovering, total_staked, total_recovered,
        current_vset_hash, stake_held_for, stake_held_until
    );
    participations~udict_set_builder(32, round_since, pdb);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() recover_stake_result(int msg_ton, slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( slice driver
    , slice halter
    , slice governor
    , cell proposed_governor
    , int reward_share
    , cell rewards_history
    , cell content
    ) = unpack_extension(extension.begin_parse());

    int query_id = s~load_uint(64);
    int ok? = s~load_int(1);
    slice validator = s~load_msg_addr();
    int round_since = s~load_uint(32);
    s.end_parse();

    ( _, _, int loan_addr ) = create_loan_address(my_address(), validator.to_builder(), round_since, loan_code);
    ( int src_wc, int src_addr ) = parse_std_addr(src);

    throw_unless(err::access_denied, (src_wc == chain::main) & (src_addr == loan_addr));

    accept_message();

    ( _, int validator_addr ) = parse_std_addr(validator);
    ( slice pd, int f? ) = participations.udict_get?(32, round_since);
    if (f?) {
        ( int state
        , _
        , int loans_size
        , cell requests
        , cell accepted
        , cell staked
        , cell recovering
        , int total_staked
        , int total_recovered
        , int current_vset_hash
        , int stake_held_for
        , int stake_held_until
        ) = unpack_participation(pd);

        ( slice request, int e? ) = recovering~udict_delete_get?(256, validator_addr);
        if (e?) {
            ( int min_payment
            , int validator_reward_share
            , int loan_amount
            , int accrue_amount
            , int stake_amount
            , _
            ) = unpack_loan(request);

            int stakers_reward_share = 65535 - reward_share;
            int reward = msg_ton - loan_amount - accrue_amount - stake_amount;
            if (reward >= 0) {
                int treasury_reward_share = 255 - validator_reward_share;
                int treasury_reward = max(min_payment, muldiv(reward, treasury_reward_share, 255));
                int validator_reward = reward - treasury_reward;
                stake_amount += validator_reward;
                int new_coins = muldiv(treasury_reward, stakers_reward_share, 65535);
                total_coins += new_coins;
                total_recovered += loan_amount + accrue_amount + new_coins;
            } else {
                ;; when reward is negative, punish the validator first
                int compensation = min(stake_amount, - reward);
                stake_amount -= compensation;
                ;; then try to take at most min_payment
                int payment = min(stake_amount, min_payment);
                stake_amount -= payment;
                int new_coins = muldiv(max(0, payment), stakers_reward_share, 65535);
                total_coins += reward + compensation + new_coins;
                total_recovered += msg_ton - stake_amount + new_coins;
            }

            if (stake_amount > 0) {
                send_msg(false, validator.to_builder(), null(), begin_cell(), stake_amount,
                    send::pay_gas_separately + send::ignore_errors
                );
            }

            if (dict_empty?(recovering)) {
                _ = participations~udict_delete?(32, round_since);
                builder reward = begin_cell()
                    .store_coins(total_staked)
                    .store_coins(total_recovered);
                rewards_history~udict_set_builder(32, round_since, reward);

                ;; remove history older than a year
                int k = -1;
                do {
                    ( k, slice v, int x? ) = rewards_history.udict_get_next?(32, k);
                    if (x?) {
                        int old? = k < now() - 60 * 60 * 24 * 365;
                        if (old?) {
                            rewards_history~udict_delete?(32, k);
                        } else {
                            x? = false;
                        }
                    }
                } until (~ x?);

                extension = pack_extension(
                    driver, halter, governor, proposed_governor, reward_share, rewards_history, content
                ).end_cell();
            } else {
                builder pdb = pack_participation(
                    state, new_dict(), loans_size, requests, accepted, staked, recovering, total_staked, total_recovered,
                    current_vset_hash, stake_held_for, stake_held_until
                );
                participations~udict_set_builder(32, round_since, pdb);
            }
        }
    }
    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() propose_governor(slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( slice driver
    , slice halter
    , slice governor
    , _
    , int reward_share
    , cell rewards_history
    , cell content
    ) = unpack_extension(extension.begin_parse());

    int query_id = s~load_uint(64);
    slice new_governor = s~load_msg_addr();
    s.end_parse();

    parse_std_addr(new_governor); ;; just check it to be a valid standard address

    throw_unless(err::access_denied, equal_slices(src, governor));

    cell proposed_governor = begin_cell()
        .store_slice(new_governor)
        .end_cell();
    extension = pack_extension(
        driver, halter, governor, proposed_governor, reward_share, rewards_history, content
    ).end_cell();

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() accept_governance(slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( slice driver
    , slice halter
    , slice governor
    , cell proposed_governor
    , int reward_share
    , cell rewards_history
    , cell content
    ) = unpack_extension(extension.begin_parse());

    int query_id = s~load_uint(64);
    s.end_parse();

    slice gs = proposed_governor.begin_parse();
    slice new_governor = gs~load_msg_addr();
    gs.end_parse();

    throw_unless(err::access_denied, equal_slices(src, new_governor));

    extension = pack_extension(driver, halter, new_governor, null(), reward_share, rewards_history, content).end_cell();

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() set_halter(slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( slice driver
    , slice halter
    , slice governor
    , cell proposed_governor
    , int reward_share
    , cell rewards_history
    , cell content
    ) = unpack_extension(extension.begin_parse());

    int query_id = s~load_uint(64);
    slice new_halter = s~load_msg_addr();
    s.end_parse();

    parse_std_addr(new_halter); ;; just check it to be a valid standard address

    throw_unless(err::access_denied, equal_slices(src, governor) | equal_slices(src, halter));

    extension = pack_extension(
        driver, new_halter, governor, proposed_governor, reward_share, rewards_history, content
    ).end_cell();

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() set_stopped(slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , _
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( slice driver
    , slice halter
    , slice governor
    , cell proposed_governor
    , int reward_share
    , cell rewards_history
    , cell content
    ) = unpack_extension(extension.begin_parse());

    int query_id = s~load_uint(64);
    int new_stopped? = s~load_int(1);
    s.end_parse();

    throw_unless(err::access_denied, equal_slices(src, governor) | equal_slices(src, halter));

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, new_stopped?, wallet_code, loan_code, extension
    );
}

() set_driver(slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( _
    , slice halter
    , slice governor
    , cell proposed_governor
    , int reward_share
    , cell rewards_history
    , cell content
    ) = unpack_extension(extension.begin_parse());

    int query_id = s~load_uint(64);
    slice new_driver = s~load_msg_addr();
    s.end_parse();

    ( int driver_wc, _ ) = parse_std_addr(new_driver); ;; just check it to be a valid standard address

    throw_unless(err::access_denied, equal_slices(src, governor) | equal_slices(src, halter));
    throw_unless(err::only_basechain_allowed, driver_wc == chain::base);

    extension = pack_extension(
        new_driver, halter, governor, proposed_governor, reward_share, rewards_history, content
    ).end_cell();

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() set_content(slice src, slice s) impure {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( slice driver
    , slice halter
    , slice governor
    , cell proposed_governor
    , int reward_share
    , cell rewards_history
    , _
    ) = unpack_extension(extension.begin_parse());

    int query_id = s~load_uint(64);
    cell new_content = s~load_ref();
    s.end_parse();

    throw_unless(err::access_denied, equal_slices(src, governor));

    extension = pack_extension(
        driver, halter, governor, proposed_governor, reward_share, rewards_history, new_content
    ).end_cell();

    builder excess = begin_cell()
        .store_uint(op::gas_excess, 32)
        .store_uint(query_id, 64);
    send_msg(false, src.to_builder(), null(), excess, 0, send::remaining_value + send::ignore_errors);

    save_data(
        total_coins, total_tokens, total_staking, total_unstaking, total_validators_stake,
        participations, stopped?, wallet_code, loan_code, extension
    );
}

() on_bounce(slice s) impure {
    ;; This function does nothing, but it is written like this to serve as a form of documentation.

    s~load_uint(32); ;; skip bounced op
    int op = s~load_uint(32);
    int query_id = s~load_uint(64);

    if (op == op::save_coins) {
        ;; Unable to save coins for staker.
        ;; This is very rare and may happen when staker's jetton wallet is already frozen.
        ;; Nothing we can do, since we don't know staker's account address in this bounced message.
        ;; Just accept bounced coins.
        return ();
    }

    if (op == op::send_new_stake) {
        ;; Loan failed to send new stake.
        ;; This must not happen, since for each round a new loan is created.
        ;; Just accept bounced coins.
        return ();
    }

    if (op == op::send_recover_stake) {
        ;; Loan failed to send recover stake.
        ;; This must not happen, since for each round a new loan is created.
        ;; Just accept bounced coins.
        return ();
    }
}

() recv_internal(int msg_ton, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice src = cs~load_msg_addr();

    if (flags & 1) {
        return on_bounce(in_msg_body);
    }

    int op = 0;
    if (in_msg_body.slice_bits()) {
        op = in_msg_body~load_uint(32);
    }

    if (op == 0) {
        if ((in_msg_body.slice_bits() == 8) & (in_msg_body.slice_refs() == 0)) {
            int c = in_msg_body~load_uint(8);
            if (c == "d"u) {
                return deposit_coins(msg_ton, src, query_id::zero);
            }

            if (c == "s"u) {
                return send_stake_first_coins(src);
            }

            if (c == "w"u) {
                return send_unstake_all_tokens(src);
            }

            if (c == "u"u) {
                return send_withdraw_tokens(src);
            }
        }

        throw(err::invalid_comment);
    }

    if (op == op::deposit_coins) {
        return deposit_coins(msg_ton, src, in_msg_body);
    }

    if (op == op::mint_tokens) {
        return mint_tokens(msg_ton, src, in_msg_body);
    }

    if (op == op::reserve_tokens) {
        return reserve_tokens(msg_ton, src, in_msg_body);
    }

    if (op == op::burn_tokens) {
        return burn_tokens(msg_ton, src, in_msg_body);
    }

    if (op == op::provide_wallet_address) {
        return provide_wallet_address(src, in_msg_body);
    }

    if (op == op::request_loan) {
        return request_loan(msg_ton, src, in_msg_body);
    }

    if (op == op::participate_in_election) {
        return participate_in_election(in_msg_body);
    }

    if (op == op::process_loan_requests) {
        return process_loan_requests(msg_ton, src, in_msg_body);
    }

    if (op == op::new_stake_rejected) {
        return new_stake_rejected(msg_ton, src, in_msg_body);
    }

    if (op == op::vset_changed) {
        return vset_changed(in_msg_body);
    }

    if (op == op::finish_participation) {
        return finish_participation(in_msg_body);
    }

    if (op == op::recover_stakes) {
        return recover_stakes(msg_ton, src, in_msg_body);
    }

    if (op == op::recover_stake_result) {
        return recover_stake_result(msg_ton, src, in_msg_body);
    }

    if (op == op::propose_governor) {
        return propose_governor(src, in_msg_body);
    }

    if (op == op::accept_governance) {
        return accept_governance(src, in_msg_body);
    }

    if (op == op::set_halter) {
        return set_halter(src, in_msg_body);
    }

    if (op == op::set_stopped) {
        return set_stopped(src, in_msg_body);
    }

    if (op == op::set_driver) {
        return set_driver(src, in_msg_body);
    }

    if (op == op::set_content) {
        return set_content(src, in_msg_body);
    }

    if (op == op::top_up) {
        return (); ;; top up TON balance, do nothing
    }

    throw(err::invalid_op);
}

() recv_external(slice in_msg_body) impure {
    int op = in_msg_body~load_uint(32);

    if (op == op::participate_in_election) {
        participate_in_election(in_msg_body);
        return ();
    }

    if (op == op::vset_changed) {
        vset_changed(in_msg_body);
        return ();
    }

    if (op == op::finish_participation) {
        finish_participation(in_msg_body);
        return ();
    }

    throw(err::invalid_op);
}

;;
;; get methods
;;

(int, int, int, int, int, cell, int, cell, cell, slice, slice, slice, cell, int, cell, cell) get_treasury_state()
    method_id {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( slice driver
    , slice halter
    , slice governor
    , cell proposed_governor
    , int reward_share
    , cell rewards_history
    , cell content
    ) = unpack_extension(extension.begin_parse());

    return
        ( total_coins
        , total_tokens
        , total_staking
        , total_unstaking
        , total_validators_stake
        , participations
        , stopped?
        , wallet_code
        , loan_code
        , driver
        , halter
        , governor
        , proposed_governor
        , reward_share
        , rewards_history
        , content
        );
}

(int, int, slice, cell, cell) get_jetton_data() method_id {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();
    ( _, _, _, _, _, _, cell content ) = unpack_extension(extension.begin_parse());

    return ( total_tokens, true, address::empty, content, wallet_code );
}

slice get_wallet_address(slice owner) method_id {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    ( int owner_wc, _ ) = parse_std_addr(owner);

    throw_unless(err::only_basechain_allowed, owner_wc == chain::base);

    ( builder wallet, _, _ ) = create_wallet_address(owner.to_builder(), my_address(), wallet_code);

    return wallet.end_cell().begin_parse();
}

slice get_loan_address(slice validator, int round_since) method_id {
    ( int total_coins
    , int total_tokens
    , int total_staking
    , int total_unstaking
    , int total_validators_stake
    , cell participations
    , int stopped?
    , cell wallet_code
    , cell loan_code
    , cell extension
    ) = load_data();

    ( int validator_wc, _ ) = parse_std_addr(validator);

    throw_unless(err::only_basechain_allowed, validator_wc == chain::base);

    ( builder loan, _, _ ) = create_loan_address(my_address(), validator.to_builder(), round_since, loan_code);

    return loan.end_cell().begin_parse();
}

(int, int, int) get_fees() method_id {
    int wallet_storage = wallet_storage_fee();
    ( int loan_storage, _ ) = loan_storage_fee();
    return
        ( fee::treasury_storage
        , wallet_storage
        , loan_storage
        );
}

int get_max_punishment(int stake) method_id {
    return max_recommended_punishment_for_validator_misbehaviour(stake);
}
